[{"title":"保不等式性","url":"/保不等式性/","content":"\n数列保不等式性的定义：设$$\\{a_n\\}$$与$$\\{b_n\\}$$均为收敛数列，若存在正数$$N_0$$，使得当$$n > N_0$$时有$$a_n ≤ b_n$$，则:\n\n$$\n\\lim_{n \\to +\\infty} a_n  ≤  \\lim_{n \\to + \\infty} b_n\n$$\n如果把定理中的条件换成严格不等式$$a_n < b_n$$，结论中仍为$$\\lim_{n \\to +\\infty} a_n  ≤  \\lim_{n \\to + \\infty} b_n$$\n\n<or>以下是一个错误证明：</or>\n\n<hr/>\n设$$\\{a_n\\}$$与$$\\{b_n\\}$$均为收敛数列，若存在正数$$N_0$$，使得当$$n > N_0$$时有$$a_n < b_n$$，则$$\\lim_{n \\to \\infty} a_n \\color{red}{<} \\lim_{n \\to \\infty} b_n$$\n$$\n\\begin{aligned}\n证：&设\\lim_{n \\to + \\infty}a_n = a，\\lim_{n \\to + \\infty}b_n = b\\\\\n&\\,\\exists N_1，当n>N_1\\quad a-\\varepsilon<a_n\\\\\n&\\,\\exists N_2，当n>N_2\\quad b_n<b+\\varepsilon\\\\\n&\\because当n > N_0时有 a_n < b_n\\\\\n&\\therefore\\,\\exists\\delta>0，当n>N_0\\quad a_n+\\delta\\le b_n\\\\\n&\\,\\exists N=max\\{N_0,N_1,N_2\\}，当n>N\\quad a-\\varepsilon+\\delta<a_n+\\delta\\le b_n<b+\\varepsilon\\\\\n&\\,即，a<b+2\\varepsilon-\\delta\\\\\n&\\,需证明：\\\\\n&\\;\\forall\\varepsilon>0，\\exists\\delta>0，有a<b+2\\varepsilon-\\delta，则a<b\\\\\n&\\;反证：倘若结论不成立，有a\\ge b，令\\varepsilon=\\frac{a-b+\\delta}{2}，则a=b+2\\varepsilon-\\delta与条件矛盾\\\\\n&\\qquad\\;\\;\\;从而必有a<b.得证\n\\end{aligned}\n$$\n\n<hr/>\n分析该证明错误原因：\n\n根据$$\\color{red}{\\exists\\delta>0，当n>N_0\\quad a_n+\\delta\\le b_n}$$可知$$\\delta \\le min\\{b_n-a_n\\}$$\n\n若当$$n \\to \\infty$$时，$$b_n-a_n$$取得最小值，那么$$\\delta = \\lim_{n \\to \\infty} (b_n-a_n)$$ ","tags":["math"]},{"title":"约瑟夫环","url":"/约瑟夫环/","content":"\n### 问题描述\n\n人们站在一个等待被处决的圈子里。 从圆圈中编号为1的人开始处决，并沿顺时针方向围绕圆圈进行。每次跳过一人，处决下一个人。对剩下的人重复该过程，直到只剩下一个人，并被释放。\n\n<img src='https://pic.downk.cc/item/5ea3daf8c2a9a83be57fbe8c.png' style=\"width:20%\"/>\n例如：18人，从编号为1开始顺时针每次跳过1人进行处决，一圈下来剩下9人\n<img src='https://pic.downk.cc/item/5ea3db37c2a9a83be58004a4.png' style=\"width:20%\"/> <img src='https://pic.downk.cc/item/5ea3db8dc2a9a83be5806415.png' style=\"width:18.5%\"/> <img src='https://pic.downk.cc/item/5ea3dba9c2a9a83be58081a4.png' style=\"width:18%\"/> <img src='https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/ex5.png' style=\"width:18%\"/>\n由于上一个处决的编号为17，因此，接下来处决2号，直至最后4号存活。\n\n### 发现规律\n\n当总人数为$$2^n$$时:\n\n| 总人数  | 存活编号 |\n| ------- | -------- |\n| 2       | 2        |\n| 4       | 4        |\n| 8       | 8        |\n| …       | …        |\n| $$2^n$$ | $$2^n$$  |\n\n即，一号待处决人逆时针的邻居，最后一位编号人员会存活。\n\n### 解决问题\n\n#### 举个例子\n\n当总人数不为$$2^n$$时:\n\n如，有18人\n1.找到最接近，却小于18的2的幂次方，即当n=4时，$$2^4 = 16$$\n2.此时，我们只需处决18-16=2人，即可重新回到$$2^n$$的易处理场景\n3.处决的两人编号分别为[1, 3]，下一个开始处决的人编号为5\n4.5号逆时针的邻居4号将存活\n\n结论与最初的模拟一致！\n\n#### 适用分析\n\n所有非$$2^n$$情况都可以这样处理吗？\n\n1.假设总人数为N，\n2.存在n，满足$$2^n < N < 2^{n+1}$$，\n3.令$$2^n+m=N$$，则有$$m < 2^n$$，\n4.我们需要预先处决m人\n5.我们知道一圈下来，我们最多处决一半的人，即$$\\frac{N}{2}$$\n6.如果$$m < \\frac{N}{2}$$，我们便可以在一圈下来预处决m人\n7.处决m人编号分别为[1, 3, ..., 2m-1]\n8.编号为2m的人将存活\n$$\n\\begin{align}\n&为证：m < \\frac{N}{2}\\\\\n&即证：m < \\frac{2^n+m}{2}\\\\\n&即证：2m < 2^n+m\\\\ \\\\\n&即证：m < 2^n\\tag{有已知条件3可得证}\n\\end{align}\n$$\n\n\n#### 高效做法\n\n联系到2进制码，最高位的1代表最接近的$$2^n$$\n其余位便是m\n结果为2m，扩大两倍，便是在最低位添加一个0\n总结为：逻辑左移一位\n\n| 值   | $$2^4$$ | $$2^3$$ | $$2^2$$ | $$2^1$$ | $$2^0$$ |\n| ---- | ------- | ------- | ------- | ------- | ------- |\n| 18   | 1       | 0       | 0       | 1       | 0       |\n| 4    | 0       | 0       | 1       | 0       | 0       |","tags":["math"]},{"title":"Python爬虫","url":"/Python爬虫/","content":"\n[慕课学习](https://www.icourse163.org/course/BIT-1001870001)\n\n```python\nimport requests\n```\n\n#### response对象的属性\n\n- r = requests.get(url)\n- r.headers()\n- r.status_code = 200访问成功 = 404访问失败\n- r.encoding 根据headers猜测响应内容编码方式\n  如果headers中没有charset，则r.encoding = iso-8859-1\n- r.apparent_encoding根据内容猜测响应内容编码方式\n- r.text 打印页面内容\n- r.content 显示内容二进制形式（如图片资源）\n\n#### requests处理异常\n\n- requests.ConnectionError 网络连接错误异常，如DNS查询失败、拒接连接等\n- requests.HTTPError HTTP错误异常\n  r.raise_for_status() 如果不是200，产生异常requests.HTTPError\n- requests.URLRequired URL缺失异常\n- requests.TooManyRedirects 超过最大重定向次数，产生重定向异常\n  对复杂连接进行访问\n- requests.ConnectTimeout 连接远程服务器超时异常\n- requests.Timeout 请求URL超时，产生超时异常\n\n```python\ndef getHTMLText(url):\n\ttry:\n\t\tr = requests.get(url, timeout=30)\n\t\tr.raise_for_status() # 如果状态码不是200，将产生异常\n\t\tr.encoding = r.apparent_encoding\n\t\treturn r.text\n\texcept:\n\t\treturn \"产生异常\"\n\t\nif __name__ == \"__main__\": # 这个if语句起什么作用\n\turl = \"www.google.com\"\n\tprint(getHTMLText(url))\n```\n\n#### Requests库的7个主要方法\n\n- requests.request() 构造一个请求，支撑以下各种方法的基础方法\n  `requests.request(method, url, 控制访问参数)`\n  method: 请求方式，对应get/put/……/OPTIONS\n\n- requests.get() 最长使用方法\n- requests.head()\n- requests.post 附加新的数据\n- requests.put() 存储资源，覆盖原URL位置的资源\n- requests.patch() 提交局部修改请求\n- requests.delete()\n\n```python\n'''\n访问控制参数演示\nparams, data, json, headers, \ncookies, auth, files, timeout, proxies, \nallow_redirects, stream, verify, cert\n'''\npayload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.post('http://httpbin.org/post', data = payload)\nprint(r.text)\n\nr = requests.post('http://httpbin.org/post', json = payload)\nprint(r.text)\n\nr = requests.get('http://httpbin.org/post', params = payload)\nprint(r.url)\n\nr = requests.post('http://httpbin.org/post', data = 'ABC')\nprint(r.text)\n\nfs = {'file': open('data.xls', 'rb')}\nr = requests.request('POST', 'http://python123.io/ws', files=fs)\n\n# 隐藏IP\npxs = {'http': 'http://user:pass@10.10.10.1:4321'\n       'http': 'https://10.10.10.1:4321'}\nr = requests.request('GET', 'http://www.baidu.com', poxies=pxs)\n```\n\n#### 作业1\n\n```python\n'''\n请编写一个小程序，“任意”找个url，测试一下成功爬取100次网页的时间。\n(某些网站对于连续爬取页面将采取屏蔽IP的策略，所以，要避开这类网站。)\n请回复代码，并给出url及在自己机器上的运行时间。\n'''\nimport datetime\nimport requests\n\ndef getHTMLText(url):\n\ttry:\n\t\tr = requests.get(url, timeout=30)\n\t\tr.raise_for_status()\n\t\tr.encoding = r.apparent_encoding\n\t\treturn r.text\n\texcept:\n\t\treturn \"产生异常\"\n\nif __name__ == \"__main__\": # 这个if语句起什么作用\n\turl = \"www.baidu.com\"\n\ts_time = datetime.datetime.now()\n\tfor i in range(0, 100):\n\t\tgetHTMLText(url)\n\te_time = datetime.datetime.now()\n\tprint('运行时间：',(e_time-s_time).microseconds, end='微秒')\n```\n\n运行时间： 31499微秒\n\n#### 爬虫认识\n\n- 规模\n  - request库--小规模\n  - scrapy库--中规模\n  - 搜索引擎--大规模\n- 网络爬虫的限制\n  1. 来源审查：判断User-Agent进行限制(浏览器)\n  2. 发布公告：robots协议（根目录下放置robots.txt）\n\n- Robots Exclusion Standard网络爬虫排除标准\n\n  ```\n  # hexo robots.txt\n  User-agent: *                  //对于任意的agent都应遵守此协议\n  Allow: /\n  Allow: /archives/\n  Allow: /categories/\n  Allow: /tags/\n  \n  Disallow: /vendors/\n  Disallow: /js/\n  Disallow: /css/\n  Disallow: /fonts/\n  Disallow: /vendors/\n  Disallow: /fancybox/\n  \n  User-agent: EtaoSpider        //此指名的恶意爬虫\n  Disallow: /                   //不能爬取根目录下的所有文件\n  ```\n\n#### 实例爬取\n\n- 一般性爬取\n\n```python\nimport requests\n\ndef getHTMLJD(url):\n    try:\n        r = requests.get(url, timeout=30)\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        return r.text[:1000]\n    except:\n        return \"爬取失败\"\n\ndef getHTMLAMS(url): # 简单伪装\n    try:\n        kv = {'user-agent': 'Mozilla/5.0'}\n        # 'User-Agent': 'python-requests/2.21.0'模拟浏览器\n        r = requests.get(url, timeout=30, headers=kv)\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        return r.text[1000:2000]\n    except:\n        return \"爬取失败\"\n\nif __name__ == \"__main__\":\n    urlJD = \"https://item.jd.com/2967929.html\"  # 京东\n    urlAMS = \"https://www.amazon.cn/gp/product/B01M8L5Z3Y\"  # 亚马逊\n    print(getHTMLJD(urlJD))\n    print(getHTMLAMS(urlAMS))\n```\n\n- 搜索引擎关键词提交接口\n  1. 百度：http://www.baidu.com/s?wd=keyword\n  2. 360：http://www.so.com/s?q=keyword\n\n```python\nimport requests\n\ndef getHTMLBaidu(url):\n    try:\n        kv = {'wd': 'Python'}\n        r = requests.get(url, params=kv)\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        return len(r.text)\n    except:\n        return \"爬取失败\"\n\ndef getHTML360(url):\n    try:\n        kv = {'q': 'Python'}\n        r = requests.get(url, params=kv)\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        return len(r.text)\n    except:\n        return \"爬取失败\"\n\nif __name__ == \"__main__\":\n    urlBaidu = \"http://www.baidu.com/s\"  # 百度\n    url360 = \"http://www.so.com/s\"  # 360\n    print(getHTMLBaidu(urlBaidu))\n    print(getHTML360(url360))\n```\n\n- 网络图片等资源下载\n\n```python\nimport requests\nimport os\n\nurl = \"https://www.jiziti.fun/img/avatar.jpg\"\nroot = \"D://test//\"\npath = root + url.split('/')[-1]\n\ntry:\n    if not os.path.exists(root):\n        os.mkdir(root)\n    if not os.path.exists(path):\n        r = requests.get(url)\n        with open(path, 'wb') as f:\n            f.write(r.content)  # r.content返回2进制文件\n            f.close()\n            print(\"文件成功保存\")\n    else:\n        print(\"文件已经存在\")\nexcept:\n    print(\"爬取失败\")\n```\n\n- IP地址归属地的自动查询\n\n```python\nimport requests\nurl = \"http://m.ip138.com/ip.asp?ip=\"\ntry:\n    r = requests.get(url + '202.204.80.112')\n    r.raise_for_status()\n    r.encoding = r.apparent_encoding\n    print(r.text[-500:])\nexcept:\n    print(\"爬取失败\")\n```\n\n#### [Beautiful Soup](https://www.crummy.com/software/BeautifulSoup/)\n\n可以解析html和xml文档\n\n`pip install beautifulsoup4`\n\n```python\nimport requests\nfrom bs4 import BeautifulSoup\n\nr = requests.get(\"http://python123.io/ws/demo.html\")\ndemo = r.text\nsoup = BeautifulSoup(demo, 'html.parser') # HTML解析器\n# soup = BeautifulSoup('<p>data</p>', 'html.parser')\nprint(soup.prettify())\n```\n\n- Beautiful Soup库解析器\n  1. html.parser `不用再安装其他包`\n  2. lxml `pip install lxml`\n  3. xml  `pip install lxml`\n  4. html5lib `pip install html5lib`\n\n- Beautiful Soup类的基本元素\n  1. Tag\n  2. Name `<tag>.name`\n  3. Attributes `<tag>.attrs`\n  4. NavigableString `<tag>.string`\n  5. Comment 注释部分处理\n\n```python\nsoup.title # <title>This is a python demo page</title>\ntag = soup.a\ntag\ntype(tag) # <class 'bs4.element.Tag'>\n\nsoup.a.name # 'a'\nsoup.a.parent.name # 'p'\nsoup.a.parent.parent.name # 'body'\n\ntag.attrs # {'href': 'http://www.icourse163.org/course/BIT-268001', 'class': ['py1'], 'id': 'link1'}\ntype(tag.attrs) # <class 'dict'>\ntag.attrs['class'] # ['py1']\n\nnewsoup = BeautifulSoup('<p><b><!-- test --></b></p>','html.parser')\nnewsoup.b.string # ' test '\nnewsoup.p.string # ' test '\ntype(newsoup.b.string) # <class 'bs4.element.Comment'>\ntype(newsoup.p.string) # <class 'bs4.element.Comment'>\n```\n\n- 遍历\n\n  - 向下遍历\n    1. contents 子节点的列表\n    2. children 子节点的迭代类型\n    3. descendants 子孙节点的迭代类型\n\n  ```python\n  soup.head # <head><title>This is a python demo page</title></head>\n  soup.head.contents # [<title>This is a python demo page</title>]\n  # '\\n'也是一个节点\n  ```\n\n  - 向上遍历\n    1. parent 父节点的标签 (html标签的父亲是其本身)\n    2. parents 节点先辈标签的迭代类型\n\n  ```python\n  for parent in soup.a.parents:\n      if parent is None:\n          print(parent) # soup本身会被遍历，soup.parent为空\n      else:\n          print(parent.name)\n  ```\n\n  - 平行遍历\n\n    **平行遍历发生在同一个父节点下**\n\n    1. next_sibling 下一个平行节点的标签\n    2. previous_sibling 上一个平行节点的标签\n    3. next_siblings 后续平行标签的迭代类型\n    4. previous_siblings 前面平行标签的迭代类型\n\n  ```python\n  soup.a.next_sibling\n  # ' and ' NavigableString是一个节点\n  for sibling in soup.a.next_siblings:\n      print(sibling)\n  ```\n\n- 其他\n\n  HTML打印prettify()\n  支持中文utf-8\n\n```python\nsoup.prettify() # 给每一个标签后面加一个换行符\nprint(soup.a.prettify())\n```\n\n#### 信息处理\n\n- 信息标记\n\n  - xml\n  - json（javascript object notation)\n  - yaml\n\n```xml\n<person>\n\t<firstName>Tian</firstName>\n    <lastName>Song</lastName>\n    <address>\n    \t<streetAddr>中关村南大街</streetAddr>\n        <city>北京</city>\n        <zipcode>100080</zipcode>\n    </address>\n    <prof>Computer System</prof><prof>Security</prof>\n</person>\n```\n\n\n  ```json\n  {\n      \"firstName\": \"Tian\",\n      \"lastName\": \"Song\",\n      \"address\": {\n          \"streetAddr\": \"中关村南大街\",\n          \"city\": \"北京\",\n          \"zipcode\": \"100080\"\n      },\n      \"prof\": [\"Computer System\", \"Security\"]\n  }\n  ```\n\n  ```yaml\n  firstName: Tian # 无类型的键值对\n  lastName: Song\n  \n  address: # 通过缩进表达所属关系\n  \tstreetAddr: 中关村南大街\n  \tcity: 北京\n  \tzipcode: 100080\n  \n  prof: # -表示并列\n  -Computer System\n  -Security\n  \n  text: | # 表达整块数据\n  这是一段很长的文本这是一段很长的文本这是一段很长的文本这是一段很长的文本这是一段很长的文本这是一段很长的文本这是一段很长的文本这是一段很长的文本这是一段很长的文本\n  ```\n\n- 提取关键信息\n\n  1. 解析信息\n\n  2. 直接搜索关键信息（准确性低）\n\n  3. 融合两种方法\n\n```python\nimport requests\nfrom bs4 import BeautifulSoup\n\nr = requests.get(\"http://python123.io/ws/demo.html\")\ndemo = r.text\nsoup = BeautifulSoup(demo, 'html.parser') # HTML解析器\nfor link in soup.find_all('a'):\n    print(link.get('href'))\n```\n\n- beautifulsoup的方法\n  - `find_all(name, attrs, recursive, string, 其他控制)`\n    这个attrs直接用的话指的是class而不是id\n    如果查找id，需要`id='×××'`\n    recursive：是否对子孙全部检索，默认为True\n    string：字符串域的特定检索\n    `import re`结合正则表达式使用\n    find_all可省略\n  - 扩展方法\n    find()：只返回一个结果，字符串类型\n    find_parents()：先辈节点，列表类型\n    find_parent()：一个结果，字符串类型\n    find_next_siblings()\n    find_next_sibling()\n    find_previous_siblings()\n    find_previous_sibling()\n\n#### 大学排名实例\n\n```python\nimport requests\nfrom bs4 import BeautifulSoup\nimport bs4\n\ndef getHTMLText(url): # 从网络上获取大学排名的网页内容\n    try:\n        r = requests.get(url, timeout=30)\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        return r.text\n    except:\n        \"获取异常\"\n    \ndef fillUnivList(ulist, html): # 将信息存储在列表中\n    soup = BeautifulSoup(html, \"html.parser\")\n    for tr in soup.find('tbody').children:\n        if isinstance(tr, bs4.element.Tag): # 过滤掉非标签类型\n            tds = tr('td') # 省略find_all\n            ulist.append([tds[0].string, tds[1].string, tds[3].string])\n\ndef printUnivList(ulist, num): # 输出结果\n    tplt = \"{0:^10}\\t{1:{3}^10}\\t{2:^10}\" # 使用{3}的参数填充\n    print(tplt.format(\"排名\", \"学校名称\", \"总分\", chr(12288)))\n    for i in range(num):\n        u = ulist[i]\n        print(tplt.format(u[0], u[1], u[2], chr(12288)))\n    \ndef main():\n    ulist = []\n    url = 'http://www.zuihaodaxue.cn/zuihaodaxuepaiming2019.html'\n    html = getHTMLText(url)\n    fillUnivList(ulist, html)\n    printUnivList(ulist, 20)\n\nmain()\n```\n\n#### 正则表达式\n\n| 操作符 | 说明                               |\n| ------ | ---------------------------------- |\n| .      | 任何单个字符                       |\n| []     | 字符集，对单个字符给出取值范围     |\n| [^]    | 非字符集，对单个字符给出排除范围   |\n| *      | 前一个字符0次或无限次扩展          |\n| +      | 前一个字符1次或无限次扩展          |\n| ?      | 前一个字符0次或1次扩展             |\n| &#x7C; | 左右表达式任意一个                 |\n| {m}    | 扩展前一个字符m次                  |\n| {m,n}  | 扩展前一个字符m至n次（含n）        |\n| ^      | 匹配字符串开头                     |\n| $      | 匹配字符串结尾                     |\n| ()     | 分组标记，内部只能使用&#124;操作符 |\n| \\d     | 数字，等价于[0-9]                  |\n| \\w     | 单词字符，等价于[A-Za-z0-9_]       |\n\n- 常用正则表达式\n  - `^[A-Za-z]+$`\n    由26个字母组成的字符串\n  - `^[A-Za-z0-9]+$`\n    由26个字母和数字组成的字符串\n  - `^-?\\d+$`\n    整数形式的字符串\n  - `^[0-9]*[1-9][0-9]*$`\n    正整数形式的字符串<or>？？？</or>\n  - `[1-9]\\d{5}`\n    中国境内邮政编码，6位\n  - `[\\u4e00-\\u9fa5]`\n    匹配中文字符\n  - `\\d{3}-\\d{8}|\\d{4}-\\d{7}`\n    国内电话号码，010-68913536\n  - `(([1-9]?\\d|1\\d{2}|2[0-4]\\d|25[0-5]).){3}([1-9]?\\d|1\\d{2}|2[0-4]\\d|25[0-5])`\n    匹配IP地址\n    0-99:`[1-9]?\\d` 100-199: `1\\d{2}` 200-249: `2[0-4]\\d` 250-255: `25[0-5]`\n\n```python\nimport re\n```\n\n- 正则表达式的表示类型\n  1. raw string类型（\\不解释为转义符）\n     如：`r[1-9]\\d{5}`\n  2. string类型\n     如：`[1-9]\\\\d{5}`\n\n- re库的主要功能函数\n  1. re.search(pattern, string, flags=0) 匹配第一个，返回match对象\n     re.I(ignorecase)匹配忽略大小写\n     re.M(multiline) ^操作符将匹配每行开始部分\n     re.S(dotall) .操作符能够匹配所有字符（包括换行符）\n  2. re.match(pattern, string, flags=0) 从开始位置匹配，返回match对象\n  3. re.findall(pattern, string, flags=0) 匹配所有，返回列表\n  4. re.split(pattern, string, maxsplit=0, flags=0) 返回列表\n     maxsplit：最大分割数，剩余部分作为最后一个元素输出\n  5. re.finditer(pattern, string, flags=0) 返回迭代类型，迭代元素为match对象\n  6. re.sub(pattern, repl, string, count=0, flags=0) 返回替换后的字符串\n     count：匹配的最大替换次数\n\n- 编译执行\n\n```python\n# 多次使用pattern\nrex = re.compile(r'[1-9]\\d{5}')\nrst = rex.search('BTS 100086')\n```\n\n- Match对象的属性与方法\n  1. string 待匹配字符串；re 正则表达式；pos 搜索字符串的开始位置；endpos\n  2. group(0)；start()；end()；span() 返回(.start(), .end())元组类型\n\n- 贪婪匹配与最小匹配\n  - `*?`、`+?`、`??`、`{m,n}?`\n\n```python\nmatch = re.search(r'PY.*N','PYANBNCNDN')\nmatch.group(0) # 默认采用贪婪模式，返回'PYANBNCNDN'\nmatch = re.search(r'PY.*?N','PYANBNCNDN')\nmatch.group(0) # 通过？实现最小匹配，返回'PYAN'\n```\n\n#### 淘宝商品比价定向爬虫实例\n\n```python\nimport requests\nimport re\n \ndef getHTMLText(url):\n    try:\n        kv = {\n            'User-Agent': 'Mozilla/5.0',\n            'Cookie': '××××', # 可手动获取\n        }\n        r = requests.get(url, timeout=30, headers=kv) # 淘宝模拟登录\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        return r.text\n    except:\n        return \"\"\n     \ndef parsePage(ilt, html): # 提取商品名称和价格信息\n    try:\n        plt = re.findall(r'\\\"view_price\\\"\\:\\\"[\\d\\.]*\\\"',html)\n        tlt = re.findall(r'\\\"raw_title\\\"\\:\\\".*?\\\"',html)\n        for i in range(len(plt)):\n            price = eval(plt[i].split(':')[1]) # eval函数去掉单双引号\n            title = eval(tlt[i].split(':')[1])\n            ilt.append([price , title])\n    except:\n        print(\"parsePage出错\")\n\ndef printGoodsList(ilt): # 输出结果\n    tplt = \"{:4}\\t{:8}\\t{:16}\"\n    print(tplt.format(\"序号\", \"价格\", \"商品名称\"))\n    count = 0\n    for g in ilt:\n        count = count + 1\n        print(tplt.format(count, g[0], g[1]))\n\ndef main():\n    goods = '书包'\n    depth = 2 # 爬取多少页\n    start_url = 'https://s.taobao.com/search?q=' + goods\n    infoList = []\n    for i in range(depth): # 循环获取页面\n        try:\n            url = start_url + '&s=' + str(44*i) # 淘宝每页显示44个商品\n            html = getHTMLText(url)\n            parsePage(infoList, html)\n        except:\n            continue\n    printGoodsList(infoList)\n     \nmain()\n```\n\n![输出结果](https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/python/2.png)\n\n#### 股票数据定向爬虫实例\n\n```python\nimport requests\nfrom bs4 import BeautifulSoup\nimport traceback # 为了调试方便\nimport re\n \ndef getHTMLText(url, code=\"utf-8\"):\n    try:\n        r = requests.get(url, timeout=30)\n        r.raise_for_status()\n        r.encoding = code # 手工获取encoding，提高运行效率\n        return r.text\n    except:\n        return \"\"\n \ndef getStockList(lst, stockURL): # 获取股票列表\n    html = getHTMLText(stockURL, \"GB2312\")\n    soup = BeautifulSoup(html, 'html.parser') \n    a = soup.find_all('a')\n    for i in a:\n        try:\n            href = i.attrs['href']\n            lst.append(re.findall(r\"[s][hz]\\d{6}\", href)[0])\n        except:\n            continue\n \ndef getStockInfo(lst, stockURL, fpath): # 根据股票雷柏啊在百度获取个股信息\n    count = 0\n    for stock in lst:\n        url = stockURL + stock + \".html\"\n        html = getHTMLText(url)\n        try:\n            if html==\"\":\n                continue\n            infoDict = {}\n            soup = BeautifulSoup(html, 'html.parser')\n            stockInfo = soup.find('div',attrs={'class':'stock-bets'})\n \n            name = stockInfo.find_all(attrs={'class':'bets-name'})[0]\n            infoDict.update({'股票名称': name.text.split()[0]})\n             \n            keyList = stockInfo.find_all('dt')\n            valueList = stockInfo.find_all('dd')\n            for i in range(len(keyList)):\n                key = keyList[i].text\n                val = valueList[i].text\n                infoDict[key] = val\n             \n            with open(fpath, 'a', encoding='utf-8') as f:\n                f.write( str(infoDict) + '\\n' )\n                count = count + 1\n                print(\"\\r当前进度: {:.2f}%\".format(count*100/len(lst)),end=\"\")\n        except:\n            #traceback.print_exc()\n            count = count + 1 # 显示进度，\\r实现不换行\n            print(\"\\r当前进度: {:.2f}%\".format(count*100/len(lst)),end=\"\")\n            continue\n \ndef main():\n    stock_list_url = 'http://quote.eastmoney.com/stock_list.html'\n    stock_info_url = 'https://gupiao.baidu.com/stock/'\n    output_file = 'D:/BaiduStockInfo.txt'\n    slist=[]\n    getStockList(slist, stock_list_url)\n    getStockInfo(slist[200:230], stock_info_url, output_file)\n \nmain()\n```\n\n#### Scrapy框架\n\n`pip install scrapy`\n\n![scrapy](https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/python/3.png)\n\n- “5+2”结构\n  1. engine：控制所有模块之间的数据流，根据条件触发事件\n  2. downloader：根据请求下载网页\n  3. scheduler：调度爬取请求\n  4. downloader middleware：修改、丢弃、新增请求或响应（request、response）\n  5. spider：提供初始url，解析response，产生item，产生额外的request\n  6. item pipelines：对item进行处理\n  7. spider middleware\n\n- 命令行使用\n\n  `scrapy <command>[options][args]`\n\n  1. `scrapy startproject [options]<name><domain>`创建工程\n  2. `scrapy genspider<name>[dir]`创建爬虫\n  3. `scrapy settings[options]`获取爬虫配置信息\n  4. `scrapy crawl<spider>`运行爬虫\n  5. `scrapy list`列出工程中的所有爬虫\n  6. `scrapy shell [url]`启动URL调试命令行\n\n- 实例\n\n  1. `scrapy startproject spy`\n     `cd spy`\n\n  2. `scrapy genspider demo spy.io`\n\n     ```python\n     import scrapy\n     \n     class DemoSpider(scrapy.Spider):\n         name = 'demo' # 爬虫名字\n         allowed_domains = ['spy.io'] # 爬取域名\n         start_urls = ['http://spy.io/'] # 初始爬取也秒\n     \n         #parse用于处理响应，解析内容形成字典，发现新的URL爬取请求\n         def parse(self, response):\n             pass\n     ```\n\n  3. 修改demo.py\n\n     ```python\n     import scrapy\n     \n     class DemoSpider(scrapy.Spider):\n         name = \"demo\"\n         #allowed_domains = [\"python123.io\"]\n         start_urls = ['https://python123.io/ws/demo.html']\n         \n         def parse(self, response):\n             fname = response.url.split('/')[-1] # 写入response内容\n             with open(fname, 'wb') as f:\n                 f.write(response.body)\n             self.log('Saved file %s.' % name)\n     ```\n\n  4. `scrapy crawl demo`\n\n- yield生成器\n  节省存储空间\n  常与for循环结合使用\n\n- CSS Selector\n  `<HTML>.css('a::attr(href)').extract()`\n\n#### 股票爬虫Scrapy实例\n\n- stocks.py（spider）\n\n```python\n# -*- coding: utf-8 -*-\nimport scrapy\nimport re\n\nclass StocksSpider(scrapy.Spider):\n    name = \"stocks\"\n    start_urls = ['http://quote.eastmoney.com/stock_list.html']\n \n    def parse(self, response):\n        for href in response.css('a::attr(href)').extract():\n            try:\n                stock = re.findall(r\"[s][hz]\\d{6}\", href)[0]\n                url = 'https://gupiao.baidu.com/stock/' + stock + '.html'\n                yield scrapy.Request(url, callback=self.parse_stock)\n            except:\n                continue\n \n    def parse_stock(self, response):\n        infoDict = {} # item类似字典\n        stockInfo = response.css('.stock-bets')\n        name = stockInfo.css('.bets-name').extract()[0]\n        keyList = stockInfo.css('dt').extract()\n        valueList = stockInfo.css('dd').extract()\n        for i in range(len(keyList)):\n            key = re.findall(r'>.*</dt>', keyList[i])[0][1:-5]\n            try:\n                val = re.findall(r'\\d+\\.?.*</dd>', valueList[i])[0][0:-5]\n            except:\n                val = '--'\n            infoDict[key]=val\n \n        infoDict.update(\n            {'股票名称': re.findall('\\s.*\\(',name)[0].split()[0] + \\\n             re.findall('\\>.*\\<', name)[0][1:-1]})\n        yield infoDict # 将信息提交给item piplines类\n```\n\n- pipelines.py\n\n```python\nclass BaidustocksPipeline(object):\n    def process_item(self, item, spider):\n        return item\n \nclass BaidustocksInfoPipeline(object): # 处理stocks类中提交的item\n    def open_spider(self, spider):\n        self.f = open('BaiduStockInfo.txt', 'w')\n \n    def close_spider(self, spider):\n        self.f.close()\n \n    def process_item(self, item, spider):\n        try:\n            line = str(dict(item)) + '\\n'\n            self.f.write(line)\n        except:\n            pass\n        return item\n```\n\n- settings.py\n\n```python\nITEM_PIPELINES = {\n    'BaiduStocks.pipelines.BaidustocksInfoPipeline': 300,\n}\n```\n\n![输出结果](https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/python/4.png)","tags":["collection"]},{"title":"数据挖掘知识整理","url":"/数据挖掘知识整理/","content":"\n## 概述\n\n简单地说，数据挖掘就是从大量数据中自动发现或“挖掘”隐藏在数据背后的有用信息的过程，数据挖掘分类如下：\n1. 按照数据集中是否已知目标变量的取值：\n   - 预测性挖掘任务(有监督学习)\n     根据某些属性的值预测特定属性的值，往往用于对新数据的预测.\n     被预测的属性一般称为目标变量(或因变量)，用来预测的变量称为输入变量(或自变量，说明变量)\n   - 描述性挖掘任务(无监督学习)\n     描述数据的特征\n     降维与可视化(数据预处理)\n     聚类分析\n     关联分析\n     孤立点检测\n2. 按照学习结果能否实时动态更新和应用，也是训练数据的方法\n   - 批量挖掘(线下学习)\n     先从历史数据集学习，再将学习结果应用于新数据.如果历史数据有更新，则需要重新学习.学习费事耗资源.\n   - 增量学习(在线学习)\n     从顺序输入的单个或小批量数据集不断学习，每次学习都廉价快速.适用于从不断变化的数据中学习，或历史数据集太大不能全部放入内存的情况.\n3. 按照学习方式的不同\n   - 基于模型的学习(理性主义)\n   - 基于实例的学习(经验主义)\n4. 预测性挖掘中按照目标变量的类型\n   - 回归(连续)\n     线性回归与多项式回归\n     分类与回归树\n     SVR\n     神经网络\n     K近邻  …\n   - 分类(离散)\n     逻辑回归\n     SVM\n     决策树与随机森林\n     神经网络\n     贝叶斯\n     K近邻 …\n\n## 数据探查与预处理\n\n$$\n数据集\\begin{cases}\n\t训练集 \\begin{cases}\n\t训练集：构建模型\n\t\\\\\n\t验证集：选择和调整模型\n\t\\end{cases}\n\\\\\\\\\n测试集：评估模型在新数据上的预测能力\n\\end{cases}\n$$\n\n| 数据集的一行 | 数据集的某列 |\n| :----------: | :----------: |\n|   数据对象   |     属性     |\n|     实例     |     变量     |\n|     记录     |      维      |\n|     观测     |     特征     |\n\n数据探查的目的是：评估数据质量，发现数据问题、理解数据、为数据预处理提供依据和思路.\n\n### 探查数据集特征\n\n1. 数据的集成程度\n2. 数据的规模\n3. 数据是否具有稀疏性\n\n### 探查数据质量\n\n1. 数据的可用性\n    属性含义、类型、取值单位、范围及约束说明\n2. 数据对应用的适合性\n    相关性、完备性、时效性\n3. 数据的代表性(抽样偏倚)\n4. 数据收集问题\n    数据的重复、缺失、不一致问题\n\n### 探查属性特征\n\n1. 属性的含义、取值单位（粒度）\n2. 属性类型与测量水平\n   <img src=\"https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/datamining/var.png\" style=\"width:100%\"/>\n     区间：没有绝对零值（即当变量值为0时不是表示没有，如温度变量，当温度为0时，并不是表示没有温度）\n     比率：有绝对零值，两个数的倍数是有意义的\n3. 描述性统计指标\n   数值型属性也可以取字符型属性的测量水平\n   - 属性取值的中心趋势\n     数值属性：均值、截尾均值、三均值\n     字符属性：众数\n   - 属性取值的离散程度\n     数值属性：极差、方差、标准差、平均绝对偏差、四分位数、四分位极差、变异系数\n     字符属性：取值个数\n   - 极端值的识别\n     根据极值和常识判断\n     根据上下截断点\n     正态分布的3σ原则\n   - 分布的对称性与中心集中度\n     <img src=\"https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/datamining/fengdu.png\" style=\"width:80%\"/>\n     <img src=\"https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/datamining/piandu.png\" style=\"width:80%\"/>\n   - 属性间取值的相关性\n     数值型变量：[Pearson相关系数](https://www.zhihu.com/question/19734616)、夹角余弦；spearman相关系数、kendall相关系数Tau-b、Hoeffding相关系数\n     名义变量：$${\\chi}^2$$检验\n     名义变量与数值变量之间：数值型变量离散化、统计方法（如T检验，Z检验，方差分析）\n4. 数据的图形表示\n\n  安斯库姆四重奏\n  <img src=\"https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/datamining/ansi.png\" style=\"width: 80%\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/datamining/kumu.png\" style=\"width: 40%\"/>\n\n  分位数图、直方图(数值型数据)或柱形图(字符型数据)、盒形图、茎叶图、饼图、散点图、折线图\n\n<hr/>\n数据预处理的目的：减少噪声、不完整和不一致数据，可以提高模型的质量，进而提高数据挖掘的有效性和准确性。（一个挖掘项目中需要的数据预处理与初始数据的质量、采用的分析方法、分析目标都有关系）\n\n### 数据清洗\n\n1. 处理错误或不一致的数据\n2. 处理缺失值\n   - 数据缺少的主要原因\n     数据不可得或获取成本太大\n     输入遗漏，理解错误，或传输错误等\n     属性值不存在（例如未婚者的配偶）\n   - 处理\n     不做处理\n     删除该条记录\n     增加标识变量\n     填补\n     - 人工确定值或固定值\n     - 均值（中位数）或众数\n     - 同类别的均值（中位数）或众数\n     - 预测值：利用分类预测技术推断出最大可能取值\n\n3. 识别处理孤立点\n   - 识别\n     常识\n     统计规则\n     (盒图中上下超过1.5倍箱体长度以外的点；正太分布均值的3个标准差之外的点)\n     聚类，…\n   - 处理\n     去除\n     视为噪声，进行平滑，盖帽法\n     保留\n\n4. 平滑噪声数据\n    噪声：变量取值存在的随机误差、不可理解的取值、错误、极端值\n    \n    - 分箱\n      排序→确定相数→确定每箱数据个数/确定箱距→分配→替换\n      分箱方法利用数据的“近邻”(即周围的值)来平滑一组有序数据的值。首先对数据进行排序，并分配到具有相同高度(每箱数据项个数相同)或宽度(等距)的不同的“箱”中；其次通过箱子的平均值(Means)、中值(Median)、或者边界值等来进行平滑处理。一种观点：通过分箱个数(分箱后为有序变量)量化变量的权重\n    \n      等高分箱：每箱数据个数相同\n      等宽分箱：每箱的箱距相同\n    \n    - 聚类\n      聚类后找出孤立点，确定其存在的噪声属性，修改该属性值\n    \n    - 回归\n\n### 数据集成\n\n1. 合并多个数据源中的数据，将之存放在一个一致的数据存储中\n   - 模式集成问题 ：同名不同义，同义不同名。\n   - 数据值冲突的检测与处理\n     例如：不同的计量单位、取值层次\n   - 数据冗余问题\n2. 纵向集成和横向集成\n\n### 数据消减\n\n数据消减(data reduction)的目的就是缩小所挖掘数据的规模，但却不会影响(或基本不影响)最终的挖掘结果。Aggregation(聚合)：例如：汇总数据代替明细数据，注意汇总的粒度；\n\n1. 维归约\n\n   - 属性构造\n     汇总属性的粒度\n     (例如：电话流失客户分月通话分钟数、电话流失客户分天通话分钟数)\n\n   - 数据压缩（PCA、奇异值分解、小波变换等）\n     数据压缩是使用数据编码或变换，以便得到原数据的“压缩”表示。如果根据压缩的数据集可以恢复原来的数据集，则数据压缩是无损的，否则，数据压缩是有损的。\n\n     - 主成分分析\n       主成分分析是对于原先提出的所有变量，建立尽可能少的新变量，使得这些新变量是两两不相关的，而且这些新变量在反映课题的信息方面尽可能保持原有的信息\n     - 小波变换\n     - 奇异值分解\n\n   - 属性子集选择\n     手工消除无用或无关属性\n\n     - 具有唯一值或近似唯一值的变量\n     - 具有单一值或近似单一值的变量\n     - 可以相互转换或同意义的变量，存在函数依赖的变量\n\n   - 特征子集选取\n     (特征子集选取就是选取最小的特征属性集合，得到的数据挖掘结果与所有特征参加的数据挖掘结果相近或完全一致)\n  - 和建模过程集成(嵌入方法)\n       多元回归分析、决策树方法\n     - 进行独立的选取工作(过滤方法和包装方法)\n       例如：用关联分析选取重要变量、用决策树方法选取重要变量\n\n2. 行规约\n\n   - 抽样\n     简单随机抽样(有放回和无放回)\n     分层抽样\n     簇抽样\n     自适应或渐进抽样\n     it’s difficulty to decide the number of observations in the sample, so at first  select little sample to mine, and then enlarge the sample gradually and estimate the result model to get a appropriate sample。\n   - 聚合\n   - 聚类\n\n### 数据转换\n\n将购买量转换为是否购买某类产品、由身份证号推出身份或年龄或性别、分布偏斜的取log，降低峰度取平方根\n\n1. 函数变换\n\n2. 数值数据规范化处理\n   不同变量常常具有不同的单位和不同的取值及变异程度。   例如：第1个变量的单位是kg，第2个变量的单位是cm，那么将第1个变量与第2个变量的值相加有何意义？  不同变量自身具有相差较大的变异时，会使在计算出的关系系数中，不同变量所占的比重大不相同。为了消除量纲影响和变量自身变异大小和数值大小的影响，需要将数据规范化。\n\n   - 最小-最大规范化\n     $$\n     v'=\\frac{v-min_A}{max_A-min_A}(new\\_max_A-new\\_min_A)+new\\_min_A\n     $$\n     A属性的原取值区间$$[min_A，max_A]$$目标新区间$$[new\\_min_A, new\\_max_A]$$目标新区建常为[0,1]\n     最小-最大规范化保留了原始数据值之间的关系。但是当有新数落在原数据区之外时，该方法将面临“越界”错误。另外，该方法受到孤立点的影响可能会比较大。\n\n   - z-score规范化(标准化)\n     将属性A的值v转换为标准化值v’，均值为μ，标准差为σ\n     $$\n     v’=\\frac{(v-μ)}{σ}\n     $$\n\n   - 十进制缩放规范化\n     将每个数值除以10的相同次方取整，A的值v规范化为v'，举例如年龄分段\n     $$\n     v' = \\frac{v}{10^j}\n     $$\n\n3. 数值数据离散化\n\n   - 无监督离散化\n     二元化\n     分箱：等高、等宽、自定义\n   - 有监督离散化\n     基于熵\n     (基于熵的离散化：先分成熵总和最小的两个区间，再将熵最大的区间分成两个小区间，依次分下去直到需要的区间数。思想同二叉决策树)\n\n4. 类别数据的数值化与数据泛化\n\n   - 名义变量(标称变量nominal)的编码\n     one-hot编码(在做回归分析时，常需要一个全为0的参照变量)\n\n   - 有序变量(ordinal)的数值化\n     设序数变量的第i个对象的值为$$x_i$$，则用它在可能取值中的顺序$$r_i$$代替$$x_i$$(假设该变量有M个有序状态)\n     以顺序代替原值$$r_i$$→$$x_i$$\n     规范化(将每个$$r_i$$映射到[0,1]区间)$$z_i$$→$$x_i$$\n     $$\n     z_i=\\frac{r_i-1}{M-1}\\qquad r_i∈\\{1,...,M\\} \\\\\n     $$\n     \n- 类别数据的泛化\n     例如：地址：国家  省  地市   区县  街道(概念层次的上升，不关注值归入“其他”)\n\n### ~~复杂数据类型的预处理：特征提取~~\n\n## 多元线性回归\n\n### 多元线性回归方程的形式和假定\n\n$$\nY=\\beta_0+\\beta_1X_1+\\cdots+\\beta_{p-1}X_{p-1}+\\varepsilon\n$$\n其中ε代表其他所有别的因素的总和\n\n1. 假定X和Y之间存在线性关系：散点图、相关系数、假设检验\n\n2. X相互独立：多重共线性检验(方差膨胀因子VIF)、变量选择法、回归优化法、pca等\n\n3. ε独立同分布：$$ ε \\sim N(0,σ ^2)$$\n\n4. 多项式回归\n$$\n  y=w_1x_1^2+w_2x_2^2+w_3x_1x_2+w_4x_1+w_5x_2+w_0\n$$\n  在线性回归方程中加入输入变量的指数项(包括变量的交互项)；指数的最高值称为degree；\n\n### 方差分析与回归目标\n\n$$\n\\overline{Y}=\\frac{1}{n}\\sum_{i=1}^ny_i\n$$\n\n- SST（total sum of squares）总离差和：反映了数据y1,y2,…,yn的波动大小；\n  $$\n  SST=\\sum_{i=1}^n(y_i-\\overline{y})^2\n  $$\n\n- SSE（error sum of squares）残差平方和：表示X不能解释的误差部分，反映除去Y与X1,X2,…,Xp-1之间的线性关系以外的因素引起的数据y1,y2,…yn的波动；\n  $$\n  SSE=\\sum_{i=1}^n(y_i-\\hat{y_i})^2\n  $$\n\n- SSR（regression sum of squares）回归平方和：反映了线性拟合值与它们的平均值的总偏差，即由变量X1,X2,…,Xp-1的变化引起的y1,y2…,yn的波动。若SSR=0，则每个拟合值相等，即y1,y2,…,yn不随着X1,X2,…,Xp-1的变化而变化\n  $$\n  SSR=\\sum_{i=1}^n(\\hat{y_i}-\\overline{y})^2\n  $$\n\n- 机器学习：$$MSE = \\frac{SSE} {n}$$\n  MAE(平均绝对误差)\n\n- 目标： min{MSE}或min{SSE}\n  成本函数（损失函数：cost(θ)=MSE (θ)\n\n### 回归参数求解\n\n1. 最小二乘\n\n   成本函数对参数求偏导，偏导为0，解方程组\n\n   - 回归方程的矩阵形式：Y=Xθ \n     $$\n     Y=Xθ\\quad →\\quad θ=(X^TX)^{-1}X^TY\n     $$\n\n   - 自变量的相关性影响矩阵求逆\n\n   - 回归关系的显著性检验\n\n   - 回归系数的检验\n\n   - 误差项的正态性检验\n\n   - 最小二乘法矩阵求逆运算量大，所以适合于数据量小的情况\n\n2. 梯度下降\n   $$\n   θ^{(next\\;step)}=θ-\\eta\\nabla_θMAE(θ)\n   $$\n   不断更新θ，使损失函数趋向最小值\n\n   - 批量梯度下降（Batch Gradient Desent）\n     $$\n     \\nabla_θMSE(θ)=\\begin{Bmatrix}\n     \\frac{\\partial}{\\partialθ_0}MSE(θ)\\\\\n     \\frac{\\partial}{\\partialθ_1}MSE(θ)\\\\\n     \\vdots\\\\\n     \\frac{\\partial}{\\partialθ_n}MSE(θ)\n     \\end{Bmatrix}=\\frac{2}{m}X^T\\cdot(X\\cdotθ-y)\n     $$\n     θ的每次更新都需要所有训练集的实例进行计算；批量法是一定朝着正确的梯度的；\n\n   - 随机梯度下降（Stochastic Gradient Desent）\n     θ的每次更新只需要随机选择一个训练实例进行计算；成本函数收敛快，但不一定达到最小，当成本函数为不规则函数时有优势。一般学习率逐渐减小​；适合大规模数据集​\n\n   - 小批量梯度下降（ Mini-batch  Gradient Desent）\n     θ的每次更新选择一组训练实例进行计算；兼具批量梯度下降的稳定性和随机梯度下降的快速性​\n\n   - 超参：学习率；迭代次数；多项式迭代中指数的最高项degree；\n\n   - 其他方法\n     - 牛顿迭代法\n       利用目标函数f(x)的泰勒展开式并保留其线性部分来求解f(x)=0的近似解\n     - 牛顿法最值优化\n       求f’(x)=0时的根，使用了二阶导数，在每轮迭代中涉及海森矩阵的求逆，计算复杂度相当高，尤其在高维问题中几乎不可行。若能以较低的计算代价寻求海森矩阵的近似逆矩阵，则可以显著降低计算的时间，这就是拟牛顿法\n     - 常用的拟牛顿法有DFP、BFGS、SR1方法等\n\n### 模型评估与误差来源分析\n\n1. 训练误差：训练集上的模型预测误差\n\n2. 泛化误差：新数据集上的模型预测误差\n    测试集的误差作为泛化误差的无偏估计\n\n3. 评估\n\n  - 好的分类模型\n    <img src=\"https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/datamining/curve1.png\" style=\"width: 50%\"/>\n    低训练误差\n    低泛化误差\n  - 拟合不足（欠拟合）：\n    <img src=\"https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/datamining/curve2.png\" style=\"width: 50%\"/>\n    较高训练误差\n    较高泛化误差\n  - 过拟合\n    <img src=\"https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/datamining/curve3.png\" style=\"width: 50%\"/>\n    低训练误差\n    较高泛化误差\n    解决办法：简化模型\n\n4. 回归方程的评估复相关系数\n$$\n  R_p^2=\\frac{SSR_p}{SST}=1-\\frac{SSE_p}{SST}\n$$\n  在一个包含p-1个自变量的线性回归模型中（即模型中有p个参数），其中$$SSE_p$$和$$SSR_p$$分别表示拟合该模型的残差平方和及回归平方和，而总平方和SST是不随p变化的一个量；复相关系数越大则该回归方程描述因变量总变化量的比例越大；回归方程中不断添加自变量时，$$R_p^2$$的值单调递增，因此，当所有M个自变量都在回归方程中，$$R_p^2$$的值最大；实际应用中，当p增加时，候选模型所对应的R2值一般开始增加较快，后逐渐趋于平缓，即增加自变量已不能显著提高拟合精度，则将由较快增加到趋于平缓的分界点处的R2值所对应的那个回归方程为最优的回归方程；\n\n5. 修正的复相关系数\n$$\n  R_a^2=1-\\left(\\frac{n-1}{n-p}\\right)\\frac{SSE_p}{SST}=1-\\frac{MSE_p}{\\left(\\frac{SST}{n-1}\\right)}\n$$\n  $$R_p^2$$中没有直接考虑模型中待估参数的个数P的作用。而一个好的模型应该既能充分反映 $$y_i(1≤i≤n)$$的变化，又包含较少的待估系数(因而包括较少的自变量)，因此将 P的控制引入到$$R_p^2$$中，得到它的一个修正量$$R_a$$.\n\n6. 模型误差的来源\n\n  - bias\n    模型类型的偏差，bias越大模型拟合度越低，欠拟合的可能性越大\n  - Variance\n    模型复杂度造成的偏差，模型复杂度越大，variance越大，过拟合的可能性越大\n  - Irreducibleerror\n    数据本身造成的误差，是不可减少的误差\n\n### 回归方程选择与正则化\n\n在一定的准则下选取对因变量影响较为显著的自变量，建立一个既合理又简单实用的回归模型\n\n1. 数据集\n   选出最佳模型参数后，根据整个训练集重新训练模型\n\n   - 训练集\n     训练集：练集构建模型\n     验证集：选择和调整模型\n   - 测试集：评估模型在新数据上的预测能力\n\n2. 逐步回归法\n\n   - 逐步回归法的基本步骤是依次拟合一系列回归方程，后一个回归方程在前一个的基础上增加或删除一个自变量\n\n   - 增加或删除某个自变量的准测用残差平方和的增加或减少量来衡量\n\n   - 一般采用偏F检验统计量\n     $$\n     F=\\frac{SSE(A)-SSE(A,X_k)}{\\frac{SSE(A,X_k)}{n-l-1}}=\\frac{SSR(X_k\\mid A)}{MSE(A,X_k)}\n     $$\n\n3. 正则化(预防过拟合)\n   在模型拟合度和模型复杂度之间进行平衡\n\n   - 岭回归\n     $$\n     J(\\theta)=MSE(\\theta)+\\alpha\\frac{1}{2}\\sum_{i=1}^n\\theta_i^2\n     $$\n\n   - Lasso回归\n     $$\n     J(\\theta)=MSE(\\theta)+\\alpha\\sum_{i=1}^n\\left|\\theta_i\\right|\n     $$\n     Lasso变量筛选能力强\n\n   - Elastic Net\n     $$\n     J(\\theta)=MSE(\\theta)+r\\alpha\\sum_{i=1}^n\\left|\\theta_i\\right|+\\frac{1-r}{2}\\alpha\\sum_{i=1}^n\\theta_i^2\n     $$\n\n4. 其它问题\n   缺失值对回归的影响\n   类别变量如何加入回归方程\n   名义变量的编码\n\n   - one-hot编码\n   - 线性回归中，为避免k个二元变量的完全线性相关，往往取消1个二元变量（其对应取值作为参照水平）\n\n   序数变量的编码\n\n   - pranks(职称)：助教、讲师、副教授、教授顺序编码：  0、1、2、3\n\n   回归系数如何理解？\n\n   - 系数:  影响方向、影响量自变量增减一个单位，因变量的变动量对类别变量，则表示当前水平相对于参照水平，因变量的变动量\n\n   数值属性的重要性\n\n   数值变量的规范化\n\n   - 标准化\n   - 最大最小规范化\n\n## 逻辑回归\n\n## 决策树\n\n## 贝叶斯-k近邻-SVM\n\n## 分类器的评估与不平衡分布类\n\n### 决策阈值\n\n二分类的决策阈值：**t=0.5**\n\n### 分类器的评估指标\n\n**二分类问题的混淆矩阵**  \n\n|       | 预测+ | 预测- | 总    |\n| :---- | ----- | ----- | ----- |\n| 实际+ | tp    | fn    | tp+fn |\n| 实际- | fp    | tn    | fp+tn |\n| 总    | tp+fp | fn+tn | all   |\n\n准确率:  (tp+tn)/all\t\t(识别率)\n误分类率：(fp+fn)/all\n\nPrecision：返回的结果中真正和信息需求相关的文档所占的百分比tp/(tp+fp)\nrecall：所有和信息需求真正相关的文档中被检索系统返回的百分比tp/(tp+fn)\n\n真正率：tp/(tp+fn) \t\t\ttp/实际+\t\t\t（灵敏度）\n真负率：tn/(fp+tn)\t\t\t tn/实际-\t\t\t（特指度）\n假正率：fp/(fp+tn)\t\t \tfp/实际-\n假负率：fn/(tp+fn)\t\t\t fn/实际+\n\n### 评估方法（验证集的划分方法）\n\n### 辅助图形\n\n### 不平衡分布类处理技术\n\n## 神经网络\n\n### 感知器模型\n\n <img src=\"https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/datamining/sensor.png\" style=\"width :55%\"/>\n\n<or>无法处理非线性分类问题</or>\n前馈式神经网络\n可以进行二分类或者三分类\n\n### BP算法\n\n它通过迭代地处理一组训练样本，将每个样本的网络预测值与实际值比较，根据二者之间的差异更新连接权值，以使得预测值与实际值之间的均方误差最小\n<or>存在梯度消失问题</or>\nha\n\n### 深度学习\n\n\n\n### 神经网络方法特点\n\n可解释性差\n\n## 组合分类与多分类\n\n## 聚类分析\n\n聚类除了进行对象的自然分类外，还可以实现数据压缩（保存类的质心，每个实例只保存所在类的质心的索引）；或者用于k近邻分类的预处理，每个实例都和同一类中的对象是近邻，可以降低计算近邻的复杂度\n\n### 聚类分析思想\n\n### 主要聚类方法\n\n### 其他","tags":["collection"]},{"title":"基于MapReduce的Kindle评论数据分析","url":"/基于MapReduce的Kindle评论数据分析/","content":"\n# Hadoop\n\n## **1**    **项目简介**\n\n### **1.1**    **背景**\n\n随着Web技术和电子商务的发展，越来越多的人会在线上对自己买过的商品发表评论。这些评论信息虽然可能会带着一些发布者的主观情感，但是能在一定程度上反映出商品的好坏以及顾客对商品的喜爱程度。基于大数据分析技术，能够从大量评论数据中分析出商品的整体评价、评论者的评论偏好等。如果能够去除评论中各种因素带来的偏差，得到的结果将能够更加准确地反映事实。\n\n商家得到从大量评论数据中分析出的顾客反馈后，将有助于商家进行销售策略的决策，而其他准备购买该商品的顾客也可以根据评论的反馈来帮助自己判断该商品是否值得购买。\n\n### **1.2**    **项目实现目的**\n\n基于MapReduce算法，通过不断地修改分析评论数据的标准来得到更加真实的分析结果。先通过分析不同时间粒度、不同评论星级下的评论分布以及各级评分商品的评论情况来得到数据的基本情况。在此基础上修正评分模型，剔除“水军”、对评论进行情感分析，结合时效性和帮助性来得到更加真实准确的评论情况。\n\n### **1.3**    **整体思路**\n\n本项目旨在分析亚马逊kindle商店1996年到2014年的百万条评论数据，修正评分模型从而得到更为真实准确的评论情况。分析过程分为以下步骤：\n\n（1）  针对评论原始数据（一级数据）进行分析，得到不同时间粒度下的评论分布、各个阶段评论的词云等二级数据。\n（2）  求出不同标准下的各个商品的平均评级作为基准对比数据。\n（3）  在基准数据的基础上，识别出评论中的“水军”，根据帮助度和时效性确定每条评论评级的权重，对评论进行情感识别分析，去除不同人之间的偏好评分差异，修正评分模型，重新对一级数据进行分析，得到更加准确的结果。\n\n以上的步骤都是基于Hadoop MapReduce编程求解，得出分析结果后使用Python制作出图表。\n\n最后，本文列出了各个阶段的分析结果。\n\n## **2**    **数据及集群配置说明**\n\n### **2.1**    **数据来源**\n\n我们从kaggle网站下载了有关亚马逊的kindle商店产品的评论数据，评论时间从1996年5月到2014年7月，总共982619条，其中每个评论者至少发布了5条评论，每个产品都至少有5条评论。\n\n### **2.2**    **数据结构说明**\n\n**数据格式:** json\n\n**数据字段：**\n\nasin:  产品编号  \nhelpful:  评论是否有帮助  \noverall:  产品评级  \nreviewText:  评论内容  \nreviewTime:  评论时间  \nreviewerID:  评论者ID  \nreviewerName:  评论者名称  \nsummary:  评论内容的概括  \nunixReviewTime:  时间戳\n\n注：helpful：[m,n]表示有n个人对这条评论进行了评价，其中m个人认为这条评论有帮助。\n\n**数据实例：**\n\n{\"reviewerID\":\"A1F6404F1VG29J\",\"asin\":\"B000F83SZQ\", reviewerName\": \"Avidreader\", \"helpful\": [0, 0], \"reviewText\": \"I enjoy vintage ... for me.\", \"overall\": 5.0, \"summary\": \"Nice vintage story\", \"unixReviewTime\": 1399248000, \"reviewTime\": \"05 5, 2014\"}\n\n### **2.3**    **集群配置说明**\n\n**集群搭建情况：**\n\n| 机器名称 | IP地址        | 硬件配置                |\n| -------- | ------------- | ----------------------- |\n| Master   | 192.168.1.246 | Core i5 双核   RAM:12GB |\n| Slaver0  | 192.168.1.243 | Core i5 双核   RAM:8GB  |\n| Slaver1  | 192.168.1.245 | Core i5 双核 RAM:8GB    |\n| Slaver2  | 192.168.1.247 | Core i5 双核   RAM:8GB  |\n\n\n\n**软件：**\n\n| 名称                   | **版本** |\n| ---------------------- | -------- |\n| Hadoop                 | 2.9.0    |\n| Ubuntu                 | 16.04.5  |\n| VMware Workstation Pro | 12.1.0   |\n| Python                 | 3.6.4    |\n| Maven                  | 3.6.0    |\n\n## **3**    **数据概览**\n\n经统计，共有评论者68223人，商品61934种。同时，没有同一评论者为同一商品留评超过两次。\n\n### **3.1**    **不同时间粒度下的评论分布**\n\n首先，在该案例中，我们首先需要了解在不同时间下评论数目的分布，从而对用户的活跃情况有一个初步认识，因为评论数目一定程度上影响了Kindle书籍的销售数目，因此提高Kindle用户的活跃度，可以提高Kindle书籍的销售情况。\n\n具体处理流程如下：\n\n1.入初始数据，根据评论的UNIX时间戳进行统计，以天作为时间粒度（原始数据中UNIX时间戳缺乏精细到小时的数据），统计出不同日期的评论数目。用例如下：\n\n**·参考代码** **CommentCountByDate.java**[^1]\n\n**输入：**{\"reviewerID\": \"A1F6404F1VG29J\", \"asin\": \"B000F83SZQ\", \"reviewerName\": \"Avidreader\", \"helpful\": [0, 0], \"reviewText\": \"I enjoy vintage ... for me.\", \"overall\": 5.0, \"summary\": \"Nice vintage story\", \"unixReviewTime\": 1399248000, \"reviewTime\": \"05 5, 2014\"} \n\n**输出：**key: 2000-03-05(评论日期)   value: 1（评论次数）\n\n2.在获取以天作为时间粒度，2000~2014年不同日期的评论数目后，利用Python统计出不同年份、月份、工作日的日平均评论数目：\n\n将统计结果绘制成折线图如下:\n<img src=\"https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/output_3_0.png\" style=\"width: 60%\"/>\n\n从上图中可以看出，Kindle的评论数目自从2010年开始呈现井喷式增长，最终在2014年达到日平均数目为2000次。这可能是因为随着移动互联网的发展，更多的人选择在kindle上购买电子书；\n<img src=\"https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/output_4_0.png\" style=\"width: 60%\"/>\n\n从上图中可以看出，日平均评论数目在1月份至7月份在525次上下波动；在8-12月份与之前相比显著下降，但仍然呈现出回升趋势。这可能是因为人们在年初的时候会一次性购买今年要阅读的书籍；\n<img src=\"https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/output_5_0.png\" style=\"width: 60%\"/>\n\n从上图中可以看出，在周日、周一时，日平均评论数目与平时相比较高。这可能是因为在周日、周一等人们有较多空闲的时间来阅读书籍和对书籍进行评论。\n\n因此，Kindle销售部门可在8-12月份增加促销活动；在周日、周一等人们有较多空闲的时间，增加商品推送，从而，提高Kindle书籍销量。\n\n### **3.2**   **各阶段评分商品的评论关键词**\n\n在获取不同商品的评分后，为分析不同评论的内容对商品评分的影响 ，我们根据商品评分的不同划分为五个区间 [1,2), [2,3), [3,4), [4,5)，[5,5]根据TF-IDF方法提取出每个评论的关键词，并统计不同评分区间下关键词的分布，绘制成图云加以展示。\n\n具体处理流程如下：\n\n**·参考代码** **CommentTermFrequency.java**[^2]\n\n1.在对评论进行分词并去除stopword后，计算出其词频；\n$$\nTF = \\frac{在某一条评论中单词w出现的次数}{该评论中去除stopword后的所有单词的数目}\n$$\n**输入：**{\"reviewerID\": \"A1F6404F1VG29J\", \"asin\": \"B000F83SZQ\", \"reviewerName\": \"Avidreader\", \"helpful\": [0, 0], \"reviewText\": \"I enjoy vintage ... for me.\", \"overall\": 5.0, \"summary\": \"Nice vintage story\", \"unixReviewTime\": 1399248000, \"reviewTime\": \"05 5, 2014\"} \n\n**输出：**key: nice B000F83SZQ+A1F6404F1VG29J   value: 0.10（词频）\n\n2.在获取该案例中评论的词频后，我们计算出每条评论中的词频-逆文件频率；\n$$\nTF - IDF_w = TF_w\\times lg\\frac{评论总数}{包含单词w的评论数}\n$$\n**输入：**nice B000F83SZQ+A1F6404F1VG29J    0.10（上一步骤中的输出） \n\n**输出：**nice B000F83SZQ+A1F6404F1VG29J    0.15 \n\n3.在得到每个评论中每个单词的词频-逆文件频率后，我们选取最高者，作为该评论的关键词；\n\n**输入：**nice B000F83SZQ+A1F6404F1VG29J    0.15 （上一步骤中的输出）\n\n**输出：** B000F83SZQ+A1F6404F1VG29J    nice \n\n4.在获取到每条评论的关键词后，根据该评论所评论的商品进行汇总，以降低文件大小，提高下一步骤中使用Python进行数据分析的效率；\n\n**输入：** B000F83SZQ+A1F6404F1VG29J    nice（上一步骤中的输出） \n\n**输出：** B000F83SZQ nice      5 \n\n5.根据前面计算出的不同商品的最终评分，利用Python对商品评论关键词的数目进行统计，得出不同评分区间下高频关键词的不同，进而分析评论内容对商品评分的影响。\n\n我们根据所得出的不同评分区间下关键词的个数，利用Python绘制成图云，如下所示：\n\n![img](https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/level.jpg)\n\n从左到右、从上到下分布为商品评分在[1,2), [2,3), [3,4), [4,5)，[5,5]评论关键词的词云分布图。\n\n从图中，我们可以看出：\n\n•   因为一星评价的商品比较少，所以其评论数目也较少，且通过TF-IDF识别出来的关键字中多为姓名，不具有代表性；\n\n•   在二星、三星评价的商品中，多为waste、horrible、deleted等负面词语，与我们的认知相一致；\n\n•   在四星、五星评价的商品中，多为recipes、diet等食谱类的描述词语，可能食谱类书籍评分均较高；同时还存在着部分cute、Christmas、children、kids等词语，可能儿童类书籍评分较高。\n\n### **3.3**   **各个商品的基准平均评级**\n\n读入原始数据，以商品编号作为键，商品评级作为值，利用MapReduce计算每种商品的平均评级：\n\n**·参考代码** **Overall.java**[^3]\n\n**输入：**{\"reviewerID\": \"A1F6404F1VG29J\", \"asin\": \"B000F83SZQ\", \"reviewerName\": \"Avidreader\", \"helpful\": [0, 0], \"reviewText\": \"I enjoy vintage ... for me.\", \"overall\": 5.0, \"summary\": \"Nice vintage story\", \"unixReviewTime\": 1399248000, \"reviewTime\": \"05 5, 2014\"} \n\n**输出：**key: B000F83SZQ（商品编号）  value: 4.89（商品评级）\n\n得到每种商品的平均评级，部分示例如下：\n\nB000QCS8YM 5.0 \nB000QFOD8E 3.5 \nB000QUCOB2 4.285714 \nB000R3NNAE 4.4444447 \nB000R93D4Y 3.96 \nB000R93D8U 3.5 \n\n之后利用商品及其评级，统计各阶段评级的商品总数，商品最终评级视为评级整数部的数值大小：\n\n**·参考代码** **CountOverall.java**[^4]\n\n**输入：**B000F83SZQ  4.89 \n\n**输出：**key: 1（商品等级）  value: 64（商品数量） \n\n利用Python统计出评级各阶段的商品总数目，并绘制成柱状图如下（Python代码：print_models.py）：\n<img src=\"https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/overallBase.png\" style=\"width: 60%\"/>\n\n| 评级     | 1    | 2    | 3     | 4     | 5    |\n| -------- | ---- | ---- | ----- | ----- | ---- |\n| 商品总数 | 64   | 823  | 10734 | 45596 | 4717 |\n\n从上图中可以看出，Kindle的各商品评级普遍较高，集中在4星左右，一星和二星的商品较少，存在一定数量的5星商品。\n\n## **4**    **商品评级修正**\n\n### **4.1**   **基于评论次数与整体评级的水军识别**\n\n1.利用之前写的统计不同日期评论数的代码，增加条件，筛选出评论数超过20条的记录。\n\n**·参考代码** **CommentCountByDateOver20.java**\n\n**输入：**{\"reviewerID\": \"A1F6404F1VG29J\", \"asin\": \"B000F83SZQ\", \"reviewerName\": \"Avidreader\", \"helpful\": [0, 0], \"reviewText\": \"I enjoy vintage ... for me.\", \"overall\": 5.0, \"summary\": \"Nice vintage story\", \"unixReviewTime\": 1399248000, \"reviewTime\": \"05 5, 2014\"} \n\n**输出：**key: 2000-03-05   value: 1 \n\n2.输入原始数据，计算每位评论者每天的评论总数，当一位评论者在一天之内评论总数超过一定数目α，或者评论总数占比当天评论总数超过某个阈值β，我们怀疑该评论者可能是职业刷评人员，最后用函数整理结果，得到这些人的评论ID。\n\n$$\n某人当天评论数 > \\alpha \\quad||\\quad\\frac{某人当天评论数}{当天评论总数} > \\beta\n$$\n**·参考代码** **IsPaidPoster1.java**\n\n**输入：**{\"reviewerID\": \"A1F6404F1VG29J\", \"asin\": \"B000F83SZQ\", \"reviewerName\": \"Avidreader\", \"helpful\": [0, 0], \"reviewText\": \"I enjoy vintage ... for me.\", \"overall\": 5.0, \"summary\": \"Nice vintage story\", \"unixReviewTime\": 1399248000, \"reviewTime\": \"05 5, 2014\"} \n\n**输出：**key: 2014-05-05,A1F6404F1VG29J   value: 20 \n\n设置α=15，β=0.25，得到潜在刷评人员60人，部分ID示例如下：\n\nA320TMDV6KCFU  A2YXNKWOGHP6AW   AAK9CEYIL2XL5   A9XRB71GIX26M AKE6711D72LTX  A1RXR105ND8OSH   A2AY83K9N60V38  A5IDWDZ2L1LA AAVZOTZWVQYRV  A1BSKHVCABJFXN 3FOL8CN5A1TFR\n\n3.输入原始数据，计算每位评论者所有评级的均值与方差，当一位评论者所有评级的均值大于4.9或小于1.1，并且所有评级的方差小于0.1，这些评论均视为恶评或好评，我们怀疑这些评论者可能是恶意刷评人员，即使不是，他们的评论也具有混淆产品评级的不当影响，我们将其等同于水军。最后用函数整理结果，只得到这些人的评论编号。为了加大该处理的可信度，我们只考虑了评论总数在100以上的评论者。\n\n$$\n\\begin{cases}\n某人所有评论评级的均值>4.9\\quad ||\\quad某人所有评论评级的均值<0.1 \\\\\n某人所有评论评级的方差 < 0.1 \\\\\n某人所有评论评级的数目 > 100\n\\end{cases}\n$$\n**·参考代码** **IsPaidPoster2.java**\n\n**输入：**{\"reviewerID\": \"A1F6404F1VG29J\", \"asin\": \"B000F83SZQ\", \"reviewerName\": \"Avidreader\", \"helpful\": [0, 0], \"reviewText\": \"I enjoy vintage ... for me.\", \"overall\": 5.0, \"summary\": \"Nice vintage story\", \"unixReviewTime\": 1399248000, \"reviewTime\": \"05 5, 2014\"} \n\n**输出：**key: A12E0W3IY6RJM   value: 4.9606986  0.037756715 \n\n最终得到潜在恶评人员144位，他们的部分ID如下：\n\nA107QCQSFVT6VN    A10C4X94VN9IG8    A1141DEY00149Z    A12E0W3IY6RJMA12NCJPL1Y3AH4    A13D5S4OXQUPRM    A141H51I3H4B1S A17YQQLSTXODGV A18L0QYPXCUD8E    A18YWXFF8FFGB2    A19BBQS3X97H2B\n\n将两种处理方式汇总，我们得到了199位潜在评论不当用户，其中5位兼具刷评与恶意评论两条性质，他们的ID以及昵称如下：\n\n| ID             | 昵称           |\n| -------------- | -------------- |\n| A1ENV91MFAEVA3 | JoT            |\n| A24F8TZ7WU4JDQ | Rebecca Palmer |\n| A28MPK002D2WJ1 | AA             |\n| A3M7QUA7XT7XIM | Jr.            |\n| A3PTWPKPXOG8Y5 | Alexis         |\n\n利用之前写的统计每种商品的平均评级的代码Overall.java，增加条件，剔除水军的评论，确保每条评论的有效性。得到新的每种商品的评论评级。\n\n**·参考代码** **OverallClean.java**\n\n**输入：**{\"reviewerID\": \"A1F6404F1VG29J\", \"asin\": \"B000F83SZQ\", \"reviewerName\": \"Avidreader\", \"helpful\": [0, 0], \"reviewText\": \"I enjoy vintage ... for me.\", \"overall\": 5.0, \"summary\": \"Nice vintage story\", \"unixReviewTime\": 1399248000, \"reviewTime\": \"05 5, 2014\"} \n\n**输出：**key: B000F83SZQ（商品编号）  value: 4.25（商品评级）\n\n利用商品及其评级，重新统计各阶段评级的商品总数，商品评级整数部的数值大小视为最终评级。\n\n| 评级     | 1    | 2    | 3     | 4     | 5    |\n| -------- | ---- | ---- | ----- | ----- | ---- |\n| 商品总数 | 70   | 872  | 11056 | 45033 | 4902 |\n\n我们发现经过处理，商品总数减少了1个，对应的事实便是，少了的商品的全部评论均由水军带来，或者说均是我们认定的无效评论。该商品的AsinID及平均评级为：\n\nB00IT2GHAS 5.0\n\n截止2018年12月，该商品具体信息如下：\n\n![img](https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/gay.png)\n\n可以发现，现阶段该商品增加了许多1星评论，而且它的评级呈现5星和1星的两极化趋势，所以，该商品很可能符合我们的猜想，全部评论均由水军带来，存在不实评价的情况。\n\n### **4.2**   **基于评论时效性及帮助度的评分修正**\n\n依据评论的帮助评分与评论时间，赋予每个评级不同帮助度与时效性的权重，重新计算剔除水军后的商品评级。\n\n输入原始数据，利用之前写的统计剔除水军后的每种商品的平均评级的代码OverallClean.java，融入每条评论评级权重信息，重新计算每种商品评级。参考参数helpful及unixReviewTime，计算每条评论的帮助度以及时效性。\n\n【帮助度】当一条评论没有帮助度时，我们将本条关于该商品的评论设为所有其他有帮助度的均值，平均其重要度。取值区间为(0, 1]；\n\n【时效性】我们用评论时间戳比上最新的2014-7-23，即unixTime=1406073600的结果再平方（以增加区别度），当做时效性的参数。取值区间为(0, 1]；\n\n$$\n\\begin{cases}\n针对同一商品，每条评论评级的得分为ax_i + by_i \\\\\n针对同一商品，每条评论评级的权重为\\frac{ax_i + by_i}{(ax_1 + by_1 + \\cdots + ax_n + by_n)}\n\\end{cases}\\\\\n其中，帮助度为x,时效性为y\n$$\n设置帮助度系数a=1，时效性系数为b=1，即，我们认为帮助度与时效性同等重要。\n\n**·参考代码** **OverallWeights.java**\n\n**输入：**{\"reviewerID\": \"A1F6404F1VG29J\", \"asin\": \"B000F83SZQ\", \"reviewerName\": \"Avidreader\", \"helpful\": [0, 0], \"reviewText\": \"I enjoy vintage ... for me.\", \"overall\": 5.0, \"summary\": \"Nice vintage story\", \"unixReviewTime\": 1399248000, \"reviewTime\": \"05 5, 2014\"} \n\n**输出：**key: B000F83SZQ（商品编号）  value: 4.249840640960779（商品评级）\n\n利用商品及其评级，重新统计各阶段评级的商品总数，商品评级整数部的数值大小视为最终评级。\n\n| 评级     | 1    | 2    | 3     | 4     | 5    |\n| -------- | ---- | ---- | ----- | ----- | ---- |\n| 商品总数 | 88   | 1086 | 12775 | 43082 | 4902 |\n\n利用Python绘制成折线图，对比三阶段的商品评级统计结果。\n\n首先是各阶段评级商品总数（Python代码：print_zhe.py）：\n<img src=\"https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/overall.png\" style=\"width: 60%\"/>\n\n| 评级           | 1    | 2    | 3     | 4     | 5    |\n| -------------- | ---- | ---- | ----- | ----- | ---- |\n| overall        | 64   | 823  | 10724 | 45596 | 4717 |\n| overallClean   | 70   | 872  | 11056 | 45033 | 4902 |\n| overallWeights | 88   | 1086 | 12775 | 43082 | 4902 |\n\n经过不断的调整，四星级商品数在逐渐下滑到三星级，一星级、二星级商品数也有微量增多，我们的评级系统变得越来越严格。\n\n同时，我们观察到评级为5的商品数目在剔除水军后增加了一部分，我们分析可能是有竞争对手恶意刷评导致评分下降。然而进行了权重修改后评级为5的商品数目没有改动，这是因为评级为5的商品必须符合每条评论均为5星，这样，无论我们如何修改权重，都无法改变商品的评级。\n\n另外，我们认为评论数与销售量在一定程度上成正比，所以我们将平均评论量类比为商品受欢迎程度，以下是各阶段商品的平均评论条数（保留两位小数）。\n\n**·参考代码** **AvgReview.java**\n<img src=\"https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/overallAvgReview.png\" style=\"width: 60%\"/>\n\n| 评级           | 1    | 2    | 3     | 4     | 5    |\n| -------------- | ---- | ---- | ----- | ----- | ---- |\n| overall        | 7.06 | 9.54 | 14.64 | 16.54 | 6.62 |\n| overallClean   | 7.07 | 9.53 | 14.54 | 16.63 | 6.58 |\n| overallWeights | 6.91 | 8.91 | 13.83 | 16.98 | 6.58 |\n\n整体上分析我们发现，1~4级评级递增时，平均评论量也是依次递增的，符合了我们的假设，即评论数与销售量在一定程度上成正比。反观5星评级的商品却又有最低的评论量，我们猜测5星评级商品会更少有争议，少了大量的吐槽评论，购买者意见较为一致，会更多的选择点赞帮助评分，而不是自行评价，同时会有更多的回购用户，而回购用户往往不会进行二次评价。\n\n​    分开来看三条折线，经过不断的调整，1~4星的平均评论量递增曲线变得愈加陡峭，具体表现为评级为1~3的商品平均评论量均在不断下降，而评级为4的商品平均评论量在不断上升。评级不同，商品平均评论量的差距也在拉大。\n\n### **4.3**   **基于**CoreNLP的评论情感识别\n\n正如我们前面的发现，评级为5的商品是无论如何都不会再被降级的，那么对于那些商品普通，评论很少，评论里描述平平的，就因为仅有的几条评论就能保持5星的情况，显然是不符合实际的。这些评级本身就十分不严谨，外加已经存在评级为5星的商品却拥有最低的商品平均评论量的现状，我们意识到了每条评论的星级本身也需要具有准确性。\n\n我们还发现，每个人的评论标准都不大相同，有的人要求严格，评分整体偏低，有的人比较随意，评分忽高忽低，所以，我们有必要给出科学的评级方式，再结合原本的评级，对每条评论本身的星级进行修改。\n\n情感分析是指利用机器提取人们对某人或事物的态度，从而发现潜在的问题用于改进或预测。商品的评价分为星级评价和文本评价。星级评价和好评率在排序算法中占据重要地位。有的商家为了提升排名，采取“五星好评返现”的方式来诱导顾客好评，但实际上用户可能对商品并不满意，因此会在文本评论或者追加评论时说出对商品不满意的真实评价。因此，对评论文本进行情感分析并使用文本评论好评率来对商品进行重新排序，指导人们根据真实评价选取商品就很显得有意义。本文中，利用CoreNLP包对商品评论进行情感分析，以对商品评分进行矫正。\n\n为简化模型，我们做出如下假设：\n\n• 评论中长度最长的一句话代表该评论的情感；\n\n由于，该模型较为复杂，需要运行较长的时间，我们仅运行前1000条的评论数据。\n\n**·参考代码SentimentAnalysis.java**\n\n**输入：**{\"reviewerID\": \"A1F6404F1VG29J\", \"asin\": \"B000F83SZQ\", \"reviewerName\": \"Avidreader\", \"helpful\": [0, 0], \"reviewText\": \"I enjoy vintage ... for me.\", \"overall\": 5.0, \"summary\": \"Nice vintage story\", \"unixReviewTime\": 1399248000, \"reviewTime\": \"05 5, 2014\"} \n\n**输出：**key: B000F83SZQ+A1F6404F1VG29J   value: 2 \n\n输出的value值表示评论的正负面情绪，其中，1~5分别代表极度负面、负面、中性、正面、极度正面）\n\n列出矫正示例如下：\n\n| 商品编号   | 评论者ID      | 原评级 | 矫正评级 |\n| :--------- | ------------- | :----- | :------- |\n| B000FA64PA | AQZH7YTWQPOBE | 4      | 2        |\n\n内容：This is a short story focused on Darth Maul's role in helping the Trade Federation gain a mining colony. It's not bad, but it's also nothing exceptional. It's fairly short so we don't really get to see any characters develop. The few events that do happen seem to go by quickly, including what should have been major battles. The story is included in the novelShadow Hunter (Star Wars: Darth Maul), which is worth reading, so don't bother to buy this one separately.\n\n| 商品编号   | 评论者ID      | 原评级 | 矫正评级 |\n| ---------- | ------------- | ------ | -------- |\n| B000FA64PK | A2QK1U70OJ74P | 5      | 5        |\n\n内容：Excellent! Very well written story, very exciting with LOTS of action. The bad guys trying to kill Leia and Han. Viki Shesh is introduced.\n\n### **4.4**   **基于时效性、帮助性、情感识别的书籍评分修正**\n\n依据情感分析得到的矫正评级，以及原评级，综合之前的纠正方法，重新计算情绪分析1000条数据的商品评级。\n\n**·参考代码** **OverallSentiment.java**\n\n得到新的对比数据：各评级商品数目、各评级平均评论量，结果如下：\n\n| 1000条数据处理结果 | 1    | 2    | 3     | 4     | 5    |\n| ------------------ | ---- | ---- | ----- | ----- | ---- |\n| 原（商品数目）     | -    | 1    | 37    | 50    | 5    |\n| 矫正（商品数目）   | -    | 10   | 75    | 8     | -    |\n| 原（平均评论量）   | -    | 15.0 | 9.51  | 11.66 | 5.6  |\n| 矫正（平均评论量） | -    | 10.4 | 10.96 | 6.5   | -    |\n\n由于数据量较少，整体分析我们发现针对原本的处理结果，商品数目是比较吻合之前的所有数据处理结果的趋势的，即商品数目集中处于4等评级左右，但是平均评论量就与之前的趋势不符，我们认为这可能是数据量少，导致数据采集不够随机而出现的偏差，所以平均评论量的测量并不能反映样本代表总体的结果，商品数目便成为了我们分析的重点。\n\n首先，我们看到情绪分析的结果对评级结果有十分大的改动。情绪分析后评级总体呈下降趋势，许多4星商品变成了3星商品，5星商品甚至完全消失，而2级商品仅有增加却没有下降，最终商品数目的数据集中点变成了3等评级。我们认为情绪分析的结果评级为5或1是鲜少的，即评论内容想要达到极度正面或极度负面是十分困难的，所以情绪分析的结果符合我们对偏好差异的修正，结果贴合现实中极少出现一致好评或一致恶评的判断情形，呈现比较中等客观的评分情形。\n\n### **4.5**   **部分得分较高电子书列表**\n\nB000QCS8YM\n\n![img](https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/1.png)\n\nB000UH5Z3A\n\n![img](https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/2.png)\n\nB002F0826C\n\n![img](https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/3.png)\n\nB002RHP5TK\n\n![img](https://cdn.jsdelivr.net/gh/jianzhiting/pic_depot/img/blog/4.png)\n\n更多更好的书单请关注我们的输出结果中的OverallWeights\n\n## **5**    **总结和展望**\n\n### **5.1**    **问题及总结**\n\n问题：缺乏相对准确的客观评分，无法通过最小二乘法等估计出相对准确的各参数取值；\n\n问题：情绪分析的模型较为复杂，导致运算速度较慢，无法对全部数据进行分析，且情绪分析结果存在误差；\n\n问题：数据与当下的时间脱轨，未能完全反应当下的需求。\n\n总结：我们的项目实现了商品评论的修正，得到了相对真实的评论情况。由于缺乏相对准确的评分、及时的数据、简单有效的模型，所以导致我们的评分修正模型仍存在一定的误差。\n\n### **5.2**   **展望**\n\n· 通过人工对Kindle产品进行判断，得出相对准确的客观评分，从而通过最小二乘估计等办法，得出相对准确的参数估计值；\n\n· 优化情感分析算法，使之可以在更多的时间内能够处理更多的数据，且判断更加准确；\n\n· 搜集最近的数据，用以验证我们的评分修正模型的准确性；\n\n· 考虑用户之间的联系，通过网络自回归模型，对评分模型进行进一步的修正等。\n\n##  附录\n\n[^1]: CommentCountByDate.java\n\n```java\n/**\n * @author 龚\n * 根据时间戳计算每天的评论数目.\n */\npublic class CommentCountByDate {\n\n    public static void main(String[] args) throws Exception {\n        Configuration conf = new Configuration();\n        String[] otherArgs = (new GenericOptionsParser(conf, args)).getRemainingArgs();\n        if (otherArgs.length < 2) {\n            System.err.println(\"Usage: Comments count by year <in> [<in>...] <out>\");\n            System.exit(2);\n        }\n        Job job = Job.getInstance(conf, \"CommentCountByDate\");\n        job.setJarByClass(CommentCountByDate.class);\n        job.setMapperClass(TokenizerMapper.class);\n        job.setCombinerClass(CountReducer.class);\n        job.setReducerClass(CountReducer.class);\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(IntWritable.class);\n        for (int i = 0; i < otherArgs.length - 1; ++i) {\n            FileInputFormat.addInputPath(job, new Path(otherArgs[i]));\n        }\n        FileOutputFormat.setOutputPath(job, new Path(otherArgs[otherArgs.length - 1]));\n        System.exit(job.waitForCompletion(true) ? 0 : 1);\n    }\n\n    public static class TokenizerMapper extends Mapper<Object, Text, Text, IntWritable> {\n        public void map(Object key, Text value, Context context) throws IOException, InterruptedException {\n            String line = value.toString();\n            Gson gson = new Gson();\n            KindleReview kindleReview = gson.fromJson(line, KindleReview.class);\n            Long unixReviewTime = kindleReview.getUnixReviewTime();\n            String reviewTime = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date(unixReviewTime * 1000));\n            context.write(new Text(reviewTime), new IntWritable(1));\n        }\n    }\n\n    public static class CountReducer extends Reducer<Text, IntWritable, Text, IntWritable> {\n        public void reduce(Text key, Iterable<IntWritable> values,\n                           Context context\n        ) throws IOException, InterruptedException {\n            int sum = 0;\n            for (IntWritable value : values) {\n                sum += value.get();\n            }\n            context.write(key, new IntWritable(sum));\n        }\n    }\n}\n```\n\nCommentByDate.py\n\n```python\n\"\"\"\n * @author 龚\n * 绘制数据概览的三张图.\n\"\"\"\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns;sns.set(style=\"whitegrid\")\n\ndata = pd.read_table('./data/count_comment_by_date', header=None)\ndata.columns = ['date', '']\ndata['date'] = pd.to_datetime(data['date'])\ndata = data.set_index('date')\n\nby_year = data.groupby(data.index.year).mean()\nplt.plot(by_year,\"-x\")\nplt.xlabel('Year')\nplt.ylabel('Comment Numbers Per Day')\nplt.show()\n\nby_month = data.groupby(data.index.month).mean()\nplt.plot(by_month,\"-x\")\nplt.xlabel('Month')\nplt.ylabel('Comment Numbers Per Day')\nplt.show()\n\nby_weekday = data.groupby(data.index.weekday).mean()\nby_weekday.index = ['Mon', 'Tues', 'Wed', 'Thur', 'Fri', 'Sat', 'Sun']\nplt.plot(by_weekday,\"-x\")\nplt.xlabel('Weekday')\nplt.ylabel('Comment Numbers Per Day')\nplt.show()\n```\n\n[^2]: CommentTermFrequency.java\n\n```java\n/**\n * @author 龚\n * 词频分析.\n */\npublic class CommentTermFrequency {\n    public static String[] stopwords = {\"a\", \"able\", \"about\", \"across\", \"after\", \"all\", \"almost\", \"also\", \"am\", \"among\",\n            \"an\", \"and\", \"any\", \"are\", \"as\", \"at\", \"be\", \"because\", \"been\", \"but\", \"by\", \"can\", \"cannot\", \"could\", \"dear\",\n            \"did\", \"do\", \"does\", \"either\", \"else\", \"ever\", \"every\", \"for\", \"from\", \"get\", \"got\", \"had\", \"has\", \"have\",\n            \"he\", \"her\", \"hers\", \"him\", \"his\", \"how\", \"however\", \"i\", \"if\", \"in\", \"into\", \"is\", \"it\", \"its\", \"just\",\n            \"least\", \"let\", \"like\", \"likely\", \"may\", \"me\", \"might\", \"most\", \"must\", \"my\", \"neither\", \"no\", \"nor\", \"not\",\n            \"of\", \"off\", \"often\", \"on\", \"only\", \"or\", \"other\", \"our\", \"own\", \"rather\", \"said\", \"say\", \"says\", \"she\",\n            \"should\", \"since\", \"so\", \"some\", \"than\", \"that\", \"the\", \"their\", \"them\", \"then\", \"there\", \"these\", \"they\",\n            \"this\", \"tis\", \"to\", \"too\", \"twas\", \"us\", \"wants\", \"was\", \"we\", \"were\", \"what\", \"when\", \"where\", \"which\",\n            \"while\", \"who\", \"whom\", \"why\", \"will\", \"with\", \"would\", \"yet\", \"you\", \"your\", \",\", \".\", \"!\", \"?\", \";\", \":\",\n            \"<\", \">\", \"/\", \"'\", \"\\\"\", \"\\\\\", \"[\", \"]\", \"{\", \"}\", \"|\", \"@\", \"#\", \"$\", \"%\", \"^\", \"&\", \"*\", \"(\", \")\", \"-\",\n            \"_\", \"=\", \"+\", \"~\", \"`\"};\n    public static Set<String> stopWordSet = new HashSet<String>(Arrays.asList(stopwords));\n\n    public static void main(String[] args) throws Exception {\n        Configuration conf = new Configuration();\n        String[] otherArgs = (new GenericOptionsParser(conf, args)).getRemainingArgs();\n        if (otherArgs.length < 2) {\n            System.err.println(\"Usage: CommentTermFrequency <in> [<in>...] <out>\");\n            System.exit(2);\n        }\n        Job job = Job.getInstance(conf, \"CommentTermFrequency\");\n        job.setJarByClass(CommentTermFrequency.class);\n        job.setMapperClass(TFMapper.class);\n        job.setCombinerClass(TFCombiner.class);\n        job.setReducerClass(TFReducer.class);\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(FloatWritable.class);\n        for (int i = 0; i < otherArgs.length - 1; ++i) {\n            FileInputFormat.addInputPath(job, new Path(otherArgs[i]));\n        }\n        FileOutputFormat.setOutputPath(job, new Path(otherArgs[otherArgs.length - 1]));\n        System.exit(job.waitForCompletion(true) ? 0 : 1);\n    }\n\n    public static class TFMapper extends Mapper<Object, Text, Text, FloatWritable> {\n        public void map(Object key, Text value, Context context) throws IOException, InterruptedException {\n            String line = value.toString();\n            Gson gson = new Gson();\n            KindleReview kindleReview = gson.fromJson(line, KindleReview.class);\n            String ReviewText = kindleReview.getReviewText();\n            String location = kindleReview.getAsin() + \"+\" + kindleReview.getReviewerID();\n            Properties props = new Properties();\n            props.put(\"annotators\", \"tokenize, ssplit, pos, parse, lemma\");\n            StanfordCoreNLP pipeline = new StanfordCoreNLP(props);\n            Annotation annotation = pipeline.process(ReviewText);\n            List<CoreMap> sentences = annotation.get(CoreAnnotations.SentencesAnnotation.class);\n            int wordCount = 0;\n            for (CoreMap sentence : sentences) {\n                for (CoreLabel token : sentence.get(CoreAnnotations.TokensAnnotation.class)) {\n                    String lemma = token.get(CoreAnnotations.LemmaAnnotation.class).toLowerCase();\n                    if (!stopWordSet.contains(lemma)) {\n                        context.write(new Text(location + \" \" + lemma), new FloatWritable(1));\n                        wordCount++;\n                    }\n                }\n            }\n            // 主要这里值使用的 \"!\"是特别构造的。 因为!的ascii比所有的字母都小。\n            context.write(new Text(location + \" !\"), new FloatWritable(wordCount));\n        }\n    }\n\n    public static class TFCombiner extends Reducer<Text, FloatWritable, Text, FloatWritable> {\n\n        float wordCount = 0;\n\n        public void reduce(Text key, Iterable<FloatWritable> values, Context context) throws IOException, InterruptedException {\n            int index = key.toString().indexOf(\" \");\n            // 因为!的ascii最小，所以在map阶段的排序后，!会出现在第一个\n            if (key.toString().substring(index + 1, index + 2).equals(\"!\")) {\n                for (FloatWritable value : values) {\n                    wordCount = value.get();\n                }\n                return;\n            }\n            float sum = 0;\n            for (FloatWritable value : values) {\n                sum += value.get();\n            }\n            float tf = sum / wordCount;\n            context.write(key, new FloatWritable(tf));\n        }\n    }\n\n    public static class TFReducer extends Reducer<Text, FloatWritable, Text, FloatWritable> {\n        public void reduce(Text key, Iterable<FloatWritable> values, Context context) throws IOException, InterruptedException {\n            for (FloatWritable value : values) {\n                context.write(key, value);\n            }\n        }\n    }\n}\n```\n\nCommentTFIDF.java\n\n```java\n/**\n * @author 龚\n * 在获取该案例中评论的词频后，我们计算出每条评论中的词频-逆文件频率${TF\n * IDF}_w=TF_w\\times\\lg\\frac{评论总数}{包含单词w的评论数}$； \n * 输入：nice B000F83SZQ+A1F6404F1VG29J    0.10（上一步骤中的输出）\n * 输出：nice B000F83SZQ+A1F6404F1VG29J    0.15\n */\npublic class CommentTFIDF { \n    public static void main(String[] args) throws Exception { \n        Configuration conf = new Configuration(); \n        String[] otherArgs = (new GenericOptionsParser(conf, args)).getRemainingArgs(); \n        if (otherArgs.length < 2) { \n            System.err.println(\"Usage: CommentTFIDF <in> [<in>...] <out>\"); \n            System.exit(2); \n        } \n        Job job = Job.getInstance(conf, \"CommentTFIDF\"); \n        job.setJarByClass(CommentTFIDF.class); \n        job.setMapperClass(TFIDFMapper.class); \n        job.setReducerClass(TFIDFReducer.class); \n        job.setOutputKeyClass(Text.class); \n        job.setOutputValueClass(Text.class); \n        for (int i = 0; i < otherArgs.length - 1; ++i) { \n            FileInputFormat.addInputPath(job, new Path(otherArgs[i])); \n        } \n        FileOutputFormat.setOutputPath(job, new Path(otherArgs[otherArgs.length - 1])); \n        System.exit(job.waitForCompletion(true) ? 0 : 1); \n    } \n    public static class TFIDFMapper extends Mapper<Object, Text, Text, Text> { \n        public void map(Object key, Text value, Context context) throws IOException, InterruptedException { \n            String line = value.toString().replaceAll(\"\\t\", \" \"); \n            String[] strs = line.split(\" \"); \n            // 获取单词 作为key \n            String word = strs[1]; \n            // 其余部分 作为value，统计单词在所有评论中出现的次数, “1” 表示出现一次。 \n            String other = strs[0] + \" \" + strs[2] + \" 1\"; \n            context.write(new Text(word), new Text(other)); \n        } \n    } \n    public static class TFIDFReducer extends Reducer<Text, Text, Text, Text> { \n        //总评论数 \n        int file_count = 982619; \n \n        public void reduce(Text key, Iterable<Text> values, Context context) throws IOException, InterruptedException { \n            float sum = 0; \n            List<String> vals = new ArrayList<>(); \n            for (Text value : values) { \n                String[] strs = value.toString().split(\" \"); \n                // 统计此单词在所有评论中出现的次数 \n                try { \n                    sum += Integer.parseInt(strs[2]); \n                    vals.add(strs[0] + \" \" + strs[1]); \n                } catch (Exception e) { \n                    System.out.println(e); \n                } \n            } \n            // 单词在所有评论中出现的次数除以总评论数 = IDF \n            double idf = Math.log10(file_count / sum); \n            String word = key.toString(); \n            for (String val : vals) { \n                String[] strs = val.split(\" \"); \n                float tf = Float.parseFloat(strs[1]); \n                String loc = strs[0]; \n                String tfidf = \"\" + (tf * idf); \n                context.write(new Text(loc + \" \" + word), new Text(tfidf)); \n            } \n        } \n    } \n}\n```\n\nCommentAbstract.java\n\n```java\n/**\n * @author 龚\n * 在得到每个评论中每个单词的词频-逆文件频率后，我们选取最高者，作为该评论的\n * 键词.\n * 输入：nice B000F83SZQ+A1F6404F1VG29J    0.15（上一步骤中的输出） \n * 输出：B000F83SZQ+A1F6404F1VG29J    nice \n */\npublic class CommentAbstract { \n    public static void main(String[] args) throws Exception { \n        Configuration conf = new Configuration(); \n        String[] otherArgs = (new GenericOptionsParser(conf, args)).getRemainingArgs(); \n        if (otherArgs.length < 2) { \n            System.err.println(\"Usage: CommentAbstract <in> [<in>...] <out>\"); \n            System.exit(2); \n        } \n        Job job = Job.getInstance(conf, \"CommentAbstract\"); \n        job.setJarByClass(CommentAbstract.class); \n        job.setMapperClass(AbstractMapper.class); \n        job.setReducerClass(AbstractReducer.class); \n        job.setOutputKeyClass(Text.class); \n        job.setOutputValueClass(Text.class); \n        for (int i = 0; i < otherArgs.length - 1; ++i) { \n            FileInputFormat.addInputPath(job, new Path(otherArgs[i])); \n        } \n        FileOutputFormat.setOutputPath(job, new Path(otherArgs[otherArgs.length - 1])); \n        System.exit(job.waitForCompletion(true) ? 0 : 1); \n    } \n \n    public static class AbstractMapper extends Mapper<Object, Text, Text, Text> { \n        public void map(Object key, Text value, Context context) throws IOException, InterruptedException { \n            String line = value.toString().replaceAll(\"\\t\", \" \"); \n            String[] strs = line.split(\" \"); \n            // 获取评论标记作为key \n            String loc = strs[0]; \n            // 其余部分 作为value \n            String other = strs[1] + \" \" + strs[2]; \n            context.write(new Text(loc), new Text(other)); \n        } \n    } \n \n    public static class AbstractReducer extends Reducer<Text, Text, Text, Text> { \n        public void reduce(Text key, Iterable<Text> values, Context context) throws IOException, InterruptedException { \n            float max = 0; \n            String abst = \"\"; \n            for (Text value : values) { \n                String[] strs = value.toString().split(\" \"); \n                String word = strs[0]; \n                float tfidf = Float.parseFloat(strs[1]); \n                if (tfidf > max) { \n                    max = tfidf; \n                    abst = word; \n                } \n            } \n            context.write(key, new Text(abst)); \n        } \n    } \n}\n```\n\nAsinAbstractCount.java\n\n```java\n/**\n * @author 龚\n * 在获取到每条评论的关键词后，根据该评论所评论的商品进行汇总，以降低文件大\n * 小，提高下一步骤中使用`Python`进行数据分析的效率.\n * 输入：B000F83SZQ+A1F6404F1VG29J    nice（上一步骤中的输出）\n * 输出：B000F83SZQ nice 5\n */\npublic class AsinAbstractCount { \n    public static void main(String[] args) throws Exception { \n        Configuration conf = new Configuration(); \n        String[] otherArgs = (new GenericOptionsParser(conf, args)).getRemainingArgs(); \n        if (otherArgs.length < 2) { \n            System.err.println(\"Usage: AsinAbstractCount <in> [<in>...] <out>\"); \n            System.exit(2); \n        } \n        Job job = Job.getInstance(conf, \"AsinAbstractCount\"); \n        job.setJarByClass(AsinAbstractCount.class); \n        job.setMapperClass(CountMapper.class); \n        job.setReducerClass(CountReducer.class); \n        job.setOutputKeyClass(Text.class); \n        job.setOutputValueClass(IntWritable.class); \n        for (int i = 0; i < otherArgs.length - 1; ++i) { \n            FileInputFormat.addInputPath(job, new Path(otherArgs[i])); \n        } \n        FileOutputFormat.setOutputPath(job, new Path(otherArgs[otherArgs.length - 1])); \n        System.exit(job.waitForCompletion(true) ? 0 : 1); \n    } \n \n    public static class CountMapper extends Mapper<Object, Text, Text, IntWritable> { \n        public void map(Object key, Text value, Context context) throws IOException, InterruptedException { \n            String line = value.toString().replaceAll(\"\\t\", \" \"); \n            String[] strs = line.split(\" \"); \n            // 获取asin，word记作为key \n            String asin = strs[0].substring(0, strs[0].indexOf('+')); \n            String word = strs[1]; \n            context.write(new Text(asin + \" \" + word), new IntWritable(1)); \n        } \n    } \n \n    public static class CountReducer extends Reducer<Text, IntWritable, Text, IntWritable> { \n        public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException { \n            int sum = 0; \n            for (IntWritable value : values) { \n                sum += value.get(); \n            } \n            context.write(key, new IntWritable(sum)); \n        } \n    } \n}\n```\n\n[^3]: Overall.java\n\n```java\n/**\n * @author 杨\n * 计算商品平均评级.\n */\npublic class Overall{\n\n    public static class MyMap extends Mapper<Object, Text, Text, IntWritable> {\n    \n        public void map(Object key, Text value, Context context) \n                throws IOException, InterruptedException {\n            \n            String review = value.toString();\n            Gson gson = new Gson();\n            KindleReview kindleReview = gson.fromJson(review, KindleReview.class);\n            int overall = kindleReview.getOverall();\n            String asin = kindleReview.getAsin();\t\t\n\t        context.write(new Text(asin), new IntWritable(overall));            \n        }\n    }\n\n  \n    public static class MyReduce extends\n            Reducer<Text,IntWritable, Text, Text> {\n\n        public void reduce(Text key, Iterable<IntWritable> values,\n                Context context) throws IOException, InterruptedException {\n            int sum = 0;\n\t        int i=0;\n\t        float ave=0;\n            for (IntWritable val : values) {\n                sum += val.get();\n\t\t        i++;\n            }\n\t        float s=(float)sum;\n\t        float j=(float)i;\n\t        ave=s/j;\n            context.write(key, new Text(\"\" + ave));\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        Configuration conf = new Configuration();\n        Job job = new Job(conf,\"overall\"); \n        job.setJarByClass(Overall.class);\t\n        job.setMapperClass(MyMap.class);\n        job.setReducerClass(MyReduce.class);\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(Text.class);\n        job.setMapOutputKeyClass(Text.class);\n        job.setMapOutputValueClass(IntWritable.class);\n        FileInputFormat.addInputPath(job, new Path(args[0]));\n        FileOutputFormat.setOutputPath(job, new Path(args[1]));\n        System.exit(job.waitForCompletion(true) ? 0 : 1);\n\n    }\n\n}\n```\n\n[^4]: CountOverall.java\n\n```java\n/**\n * @author 杨\n * 计算每个商品评级的商品总数.\n */\npublic class CountOverall{\n   \n    public static class MyMap extends Mapper<Object, Text, Text, IntWritable> {\n        \n        private final static IntWritable one = new IntWritable(1); \n        private Text word = new Text(); \n\n    \n        public void map(Object key, Text value, Context context) \n                throws IOException, InterruptedException {\n            \n\t\t    String[] str = value.toString().split(\"\\\\s+\");\n\t\t    double i= Double.parseDouble(str[1]);\n\t\t    int j=(int)i;\n            word.set(\"\" + j);\t    \t\n\t    \tcontext.write(word,one);\n       \n        }\n    }\n\n   \n    public static class MyReduce extends\n            Reducer<Text, IntWritable, Text, IntWritable> {\n\n        public void reduce(Text key, Iterable<IntWritable> values,\n                Context context) throws IOException, InterruptedException {\n            int sum = 0;\n            for (IntWritable val : values) {\n                sum += val.get();\n            }\n            context.write(key, new IntWritable(sum));\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        Configuration conf = new Configuration();\n        Job job = new Job(conf,\"CountOverall\"); \n        job.setJarByClass(CountOverall.class);\n\n        job.setMapperClass(MyMap.class);\n        job.setCombinerClass(MyReduce.class);\n        job.setReducerClass(MyReduce.class);\n\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(IntWritable.class);\n\n        FileInputFormat.addInputPath(job, new Path(args[0]));\n        FileOutputFormat.setOutputPath(job, new Path(args[1]));\n\n        System.exit(job.waitForCompletion(true) ? 0 : 1);\n\n    }\n\n}\n```\n\nprint_models.py\n\n```python\n\"\"\"\n * @author 简\n * 打印商品评级及各评级总数的柱状图.\n\"\"\"\nimport matplotlib.pyplot as plt\n\nfile = open(\"./KR/out/countOverall/part-r-00000\")\nx_list = []\ny_list = []\n\nline = file.readline()\nwhile line:\n    x = line.split()\n    x_list.append(x[0])\n    y_list.append(int(x[1]))\n    line = file.readline()\n\nfile.close()\n\nplt.bar(range(len(y_list)), y_list, width=0.8, facecolor=\"#4C72B0\", edgecolor=\"white\", tick_label=x_list)\nplt.xlabel('Level')\nplt.ylabel('Amount')\nplt.show()\n```\n\nCommentCountByDateOver20.java\n\n```java\n/**\n * @author 龚\n * 根据时间戳计算每天的评论数目，筛选出评论数目超过20条的记录.\n */\npublic class CommentCountByDateOver20 {\n\n    public static void main(String[] args) throws Exception {\n        Configuration conf = new Configuration();\n        String[] otherArgs = (new GenericOptionsParser(conf, args)).getRemainingArgs();\n        if (otherArgs.length < 2) {\n            System.err.println(\"Usage: Comments count by year <in> [<in>...] <out>\");\n            System.exit(2);\n        }\n        Job job = Job.getInstance(conf, \"CommentCountByDateOver20\");\n        job.setJarByClass(CommentCountByDateOver20.class);\n        job.setMapperClass(TokenizerMapper.class);\n        job.setCombinerClass(CountReducer.class);\n        job.setReducerClass(CountReducer.class);\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(IntWritable.class);\n        /*for (int i = 0; i < otherArgs.length - 1; ++i) {\n            FileInputFormat.addInputPath(job, new Path(otherArgs[i]));\n        }\n        FileOutputFormat.setOutputPath(job, new Path(otherArgs[otherArgs.length - 1]));*/\n        for (int i = 0; i < otherArgs.length - 1; ++i) {\n            FileInputFormat.addInputPath(job, new Path(otherArgs[i]));\n        }\n        FileOutputFormat.setOutputPath(job, new Path(otherArgs[otherArgs.length - 1]));\n        System.exit(job.waitForCompletion(true) ? 0 : 1);\n    }\n\n    public static class TokenizerMapper extends Mapper<Object, Text, Text, IntWritable> {\n        public void map(Object key, Text value, Context context) throws IOException, InterruptedException {\n            String line = value.toString();\n            Gson gson = new Gson();\n            KindleReview kindleReview = gson.fromJson(line, KindleReview.class);\n            Long unixReviewTime = kindleReview.getUnixReviewTime();\n            String reviewTime = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date(unixReviewTime * 1000));\n            context.write(new Text(reviewTime), new IntWritable(1));\n        }\n    }\n\n    public static class CountReducer extends Reducer<Text, IntWritable, Text, IntWritable> {\n        public void reduce(Text key, Iterable<IntWritable> values,\n                           Context context\n        ) throws IOException, InterruptedException {\n            int sum = 0;\n            for (IntWritable value : values) {\n                sum += value.get();\n            }\n            if(sum > 20)\n                context.write(key, new IntWritable(sum));\n        }\n    }\n}\n```\n\nIsPaidPoster1.java\n\n```java\n/**\n * @author 简\n * 根据每人每天的评论条数筛选出潜在水军.\n */\npublic class IsPaidPoster1 {\n\n\tpublic static Map<String,Integer> rely = new HashMap<>();\n\t\n\tpublic static class TokenizerMapper extends Mapper<Object, Text, Text, IntWritable> {\n\n\t\tpublic void map(Object key, Text value, Context context) throws IOException,InterruptedException{\n\t\t\t\n\t\t\tString line = value.toString();\n            Gson gson = new Gson();\n            KindleReview kindleReview = gson.fromJson(line, KindleReview.class);\n            Long unixReviewTime = kindleReview.getUnixReviewTime();\n            String reviewTime = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date(unixReviewTime * 1000));\n            if(rely.containsKey(reviewTime)){\n                String reviewID = kindleReview.getReviewerID();\n                context.write(new Text(reviewTime + \",\" + reviewID), new IntWritable(1));\n            }\n\t\t}\n\t}\n\t\n\tpublic static class IntSumReducer extends Reducer<Text, IntWritable, Text, IntWritable>{\n        \n\t\tpublic void reduce(Text key,Iterable<IntWritable> values,Context context)throws IOException,InterruptedException{\n            \n            String str = key.toString();\n            String words[] = str.split(\",\");\n            int amount = rely.get(words[0]);\n            int sum = 0;\n            for (IntWritable value : values) {\n                sum += value.get();\n            }\n            if(sum > 15||sum > 0.25*amount)//某人某天评论数超过15条，或者，某人某天评论数超过评论总数的25%\n\t\t\t    context.write(key, new IntWritable(sum));\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception{\n\t\tConfiguration configuration=new Configuration();\n\t\tString[] otherArgs=new GenericOptionsParser(configuration,args).getRemainingArgs();\n\t\tif(otherArgs.length!=2){\n\t\t\tSystem.err.println(\"Usage:reverseIndex <in> <out>\");\n\t\t\tSystem.exit(2);\n\t\t}\n\t\tFileSystem fs=FileSystem.get(configuration);\n\t\tInputStream in = null;\n\t\tPath name1 = new Path(\"hdfs://localhost:9000/user/hadoop/commentCountByDateOver20/part-r-00000\");\n\t\tin = fs.open(name1);\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(in));\n\n\t\t//rely\n        String line = \"\";\n        line = br.readLine();\n\t\twhile (line != null) {\n            StringTokenizer itr = new StringTokenizer(line);\n            String str = itr.nextToken();\n\t\t\tint integer = Integer.parseInt(itr.nextToken());\n            rely.put(str, integer);\n\t\t\tline = br.readLine();\n\t\t}\n\t\tbr.close();\n        in.close();\n\t\t\t\t\n\t\t//配置作业名\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tJob job=new Job(configuration, \"IsPaidPoster1\");\n\t\tjob.setJarByClass(IsPaidPoster1.class);\n\t\tjob.setMapperClass(TokenizerMapper.class);\n        //是可以按文件名进行partition的\n\t\tjob.setCombinerClass(IntSumReducer.class);\n\t\tjob.setReducerClass(IntSumReducer.class);\n\t\tjob.setOutputKeyClass(Text.class);\n\t\tjob.setOutputValueClass(IntWritable.class);\t\n        FileInputFormat.addInputPath(job, new Path(otherArgs[0]));\n\t\tFileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));\n\n        if(job.waitForCompletion(true)) {\n            InputStream in2 = null;\n            Path name2 = new Path(\"hdfs://localhost:9000/user/hadoop/\" +otherArgs[1]+ \"/part-r-00000\");\n            Path name3 = new Path(\"hdfs://localhost:9000/user/hadoop/\"+otherArgs[1]+\"/ans\");\t\t\n            in2 = fs.open(name2);\n            FSDataOutputStream fileout = fs.create(name3);\n\t        BufferedReader br2 = new BufferedReader(new InputStreamReader(in2));\n\t\t\tBufferedWriter out = new BufferedWriter(new OutputStreamWriter(fileout));\n\t        line = \"\";\n\t        line = br2.readLine();\n            Set<String> hs = new HashSet<String>();\n            int cnt = 0;\n\t        while (line != null) {\n                String words[] = line.split(\"[,\\\\p{Blank}]\");\n                if(!hs.contains(words[1])){\n                    cnt++;\n                    hs.add(words[1]);\n\t\t\t\t    out.write(words[1] + \"\\n\");\n                }\n\t            line = br2.readLine();\n\t        }\n            //out.write(\"\"+ cnt + \"\\n\");\n\t        br2.close();\n            in2.close();\n            out.flush();\n\t\t\tout.close();\n\t\t}\n\t\tSystem.exit(job.waitForCompletion(true)?0:1);\n\t}\n}\n```\n\nIsPaidPoster2.java\n\n```java\n/**\n * @author 简\n * 根据一个人所有的评论是否均为好评或恶评筛选出潜在水军.\n */\npublic class IsPaidPoster2 {\n\t\n\tpublic static class TokenizerMapper extends Mapper<Object, Text, Text, IntWritable> {\n\n\t\tpublic void map(Object key, Text value, Context context) throws IOException,InterruptedException{\n\t\t\t\n\t\t\tString line = value.toString();\n            Gson gson = new Gson();\n            KindleReview kindleReview = gson.fromJson(line, KindleReview.class);\n            String reviewID = kindleReview.getReviewerID();\n            int overall = kindleReview.getOverall();\n            context.write(new Text(reviewID), new IntWritable(overall));\n\t\t}\n\t}\n\t\n\tpublic static class IntSumReducer extends Reducer<Text, IntWritable, Text, Text>{\n        \n\t\tpublic void reduce(Text key,Iterable<IntWritable> values,Context context)throws IOException,InterruptedException{\n            \n            ArrayList<Integer> overall = new ArrayList<Integer>();\n            \n            float avg = 0;\n            for (IntWritable value : values) {\n                int val = value.get();\n                avg += val;\n                overall.add(val);\n            }\n            int cnt = overall.size();\n            if(cnt > 100){//当某个人的评论条数超过100条时\n                avg = avg/cnt;\n                if(avg < 1.1f||avg > 4.9f){//评级均为恶评或好评\n                    float sum = 0;\n                    for(int integer : overall){\n                        sum += (integer-avg)*(integer-avg);\n                    }\n                    sum = sum/cnt;\n                    if(sum < 0.1)//方差小于0.1\n\t\t                context.write(key, new Text(\"\" + avg + \" \" + sum));\n                }\n            }\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception{\n\t\tConfiguration configuration=new Configuration();\n\t\tString[] otherArgs=new GenericOptionsParser(configuration,args).getRemainingArgs();\n\t\tif(otherArgs.length!=2){\n\t\t\tSystem.err.println(\"Usage:reverseIndex <in> <out>\");\n\t\t\tSystem.exit(2);\n\t\t}\n\t\tFileSystem fs=FileSystem.get(configuration);\n\t\t\t\t\n\t\t//配置作业名\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tJob job=new Job(configuration, \"IsPaidPoster2\");\n\t\tjob.setJarByClass(IsPaidPoster2.class);\n\t\tjob.setMapperClass(TokenizerMapper.class);\n\t\tjob.setReducerClass(IntSumReducer.class);\n        job.setMapOutputKeyClass(Text.class);\n        job.setMapOutputValueClass(IntWritable.class);\n\t\tjob.setOutputKeyClass(Text.class);\n\t\tjob.setOutputValueClass(Text.class);\t\n        FileInputFormat.addInputPath(job, new Path(otherArgs[0]));\n\t\tFileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));\n\n        if(job.waitForCompletion(true)) {\n            InputStream in2 = null;\n            Path name2 = new Path(\"hdfs://localhost:9000/user/hadoop/\" +otherArgs[1]+ \"/part-r-00000\");\n            Path name3 = new Path(\"hdfs://localhost:9000/user/hadoop/\"+otherArgs[1]+\"/ans\");\t\t\n            in2 = fs.open(name2);\n            FSDataOutputStream fileout = fs.create(name3);\n\t        BufferedReader br2 = new BufferedReader(new InputStreamReader(in2));\n\t\t\tBufferedWriter out = new BufferedWriter(new OutputStreamWriter(fileout));\n\n            InputStream in1 = null;\n            Path name1 = new Path(\"hdfs://localhost:9000/user/hadoop/isPaidPoster1/ans\");\t\n            in1 = fs.open(name1);\n\t        BufferedReader br1 = new BufferedReader(new InputStreamReader(in1));\n\n\t        String line = \"\";\n            Set<String> hs = new HashSet<String>();\n            int cnt = 0;\n            line = br1.readLine();\n\t        while (line != null) {\n                cnt++;\n                hs.add(line);\n\t\t\t    out.write(line + \"\\n\");\n\t            line = br1.readLine();\n\t        }\n            line = br2.readLine();\n\t        while (line != null) {\n                String words[] = line.split(\"[\\\\p{Blank}]\");\n                if(!hs.contains(words[0])){\n                    cnt++;\n\t\t\t        out.write(words[0] + \"\\n\");\n                }\n\t            line = br2.readLine();\n\t        }\n            //out.write(\"\"+ cnt + \"\\n\");\n            br1.close();\n            in1.close();\n\t        br2.close();\n            in2.close();\n            out.flush();\n\t\t\tout.close();\n\t\t}\n\t\tSystem.exit(job.waitForCompletion(true)?0:1);\n\t}\n}\n```\n\nOverallClean.java\n\n```java\n/**\n * @author 杨\n * 剔除水军，重新计算各商品平均评级.\n */\npublic class OverallClean{\n\n    public static Set<String> rely = new HashSet<String>();\n\n    public static class MyMap extends Mapper<Object, Text, Text, IntWritable> {\n    \n        public void map(Object key, Text value, Context context) \n                throws IOException, InterruptedException {\n            \n            String review = value.toString();\n            Gson gson = new Gson();\n            KindleReview kindleReview = gson.fromJson(review, KindleReview.class);\n            int overall = kindleReview.getOverall();\n            String asin = kindleReview.getAsin();\n            \n            String reviewId = kindleReview.getReviewerID();\n            if(!rely.contains(reviewId))//去除不良评判人员\n\t            context.write(new Text(asin), new IntWritable(overall));            \n        }\n    }\n\n  \n    public static class MyReduce extends\n            Reducer<Text,IntWritable, Text, Text> {\n\n        public void reduce(Text key, Iterable<IntWritable> values,\n                Context context) throws IOException, InterruptedException {\n            int sum = 0;\n\t        int i=0;\n\t        float ave=0;\n            for (IntWritable val : values) {\n                sum += val.get();\n\t\t        i++;\n            }\n\t        float s=(float)sum;\n\t        float j=(float)i;\n\t        ave=s/j;\n            context.write(key, new Text(\"\" + ave));\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        Configuration conf = new Configuration();\n\n        FileSystem fs=FileSystem.get(conf);\n\t\tInputStream in = null;\n\t\tPath name = new Path(\"hdfs://localhost:9000/user/hadoop/isPaidPoster2/ans\");\n\t\tin = fs.open(name);\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(in));\n\n\t\t//rely\n        String line = \"\";\n        line = br.readLine();\n\t\twhile (line != null) {\n            rely.add(line);\n\t\t\tline = br.readLine();\n\t\t}\n\t\tbr.close();\n        in.close();\n\n        Job job = new Job(conf,\"OverallClean\"); \n        job.setJarByClass(OverallClean.class);\t\n        job.setMapperClass(MyMap.class);\n        job.setReducerClass(MyReduce.class);\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(Text.class);\n        job.setMapOutputKeyClass(Text.class);\n        job.setMapOutputValueClass(IntWritable.class);\n        FileInputFormat.addInputPath(job, new Path(args[0]));\n        FileOutputFormat.setOutputPath(job, new Path(args[1]));\n\n        if(job.waitForCompletion(true)) {\n            InputStream in2 = null;\n            Path name2 = new Path(\"hdfs://localhost:9000/user/hadoop/\" +args[1]+ \"/part-r-00000\");\n            Path name3 = new Path(\"hdfs://localhost:9000/user/hadoop/\"+args[1]+\"/ans\");\t\t\n            in2 = fs.open(name2);\n            FSDataOutputStream fileout = fs.create(name3);\n\t        BufferedReader br2 = new BufferedReader(new InputStreamReader(in2));\n\t\t\tBufferedWriter out = new BufferedWriter(new OutputStreamWriter(fileout));\n\n            InputStream in1 = null;\n            Path name1 = new Path(\"hdfs://localhost:9000/user/hadoop/overall/part-r-00000\");\t\n            in1 = fs.open(name1);\n\t        BufferedReader br1 = new BufferedReader(new InputStreamReader(in1));\n\n\t        line = \"\";\n            Set<String> hs = new HashSet<String>();\n            int cnt = 0;\n            line = br2.readLine();\n\t        while (line != null) {\n                String words[] = line.split(\"[\\\\p{Blank}]\");\n                hs.add(words[0]);\n\t            line = br2.readLine();\n\t        }\n            out.write(\"Lack...\\n\");\n            line = br1.readLine();\n\t        while (line != null) {\n                String words[] = line.split(\"[\\\\p{Blank}]\");\n                if(!hs.contains(words[0])){\n                    cnt++;\n\t\t\t        out.write(words[0] + \" \" + words[1] + \"\\n\");\n                }\n\t            line = br1.readLine();\n\t        }\n            out.write(\"\"+ cnt + \"\\n\");\n            br1.close();\n            in1.close();\n\t        br2.close();\n            in2.close();\n            out.flush();\n\t\t\tout.close();\n\t\t}\n        System.exit(job.waitForCompletion(true) ? 0 : 1);\n    }\n}\n```\n\nOverallWeights.java\n\n```java\n/**\n * @author 简\n * 根据帮助度和时效性，更改同一商品每条评论的评级权重，重新计算剔除水军\n * 评论后的各商品平均评级.\n */\npublic class OverallWeights {\n    \n    public static Set<String> rely = new HashSet<String>();\n\t\n\tpublic static class TokenizerMapper extends Mapper<Object, Text, Text, Text> {\n\n\t\tpublic void map(Object key, Text value, Context context) throws IOException,InterruptedException{\n\t\t\t\n\t\t\tString line = value.toString();\n            Gson gson = new Gson();\n            KindleReview kindleReview = gson.fromJson(line, KindleReview.class);\n            String asin = kindleReview.getAsin();\n            int overall = kindleReview.getOverall();\n            String[] help = kindleReview.getHelpful();\n            Long unixReviewTime = kindleReview.getUnixReviewTime();\n\n            String reviewId = kindleReview.getReviewerID();\n            if(!rely.contains(reviewId))//去除不良评判人员\t\t\n                context.write(new Text(asin), new Text(overall + \",\" + help[0] + \",\" + help [1] + \",\" + unixReviewTime));\n\t\t}\n\t}\n\t\n\tpublic static class IntSumReducer extends Reducer<Text, Text, Text, Text>{\n        \n\t\tpublic void reduce(Text key,Iterable<Text> values,Context context)throws IOException,InterruptedException{\n            \n            int a = 1, b = 1;//帮助度和时效性的比例为1：1\n            ArrayList<Integer> overall = new ArrayList<Integer>();\n            ArrayList<Float> help = new ArrayList<Float>();\n            ArrayList<Long> unixTime = new ArrayList<Long>();\n            \n            for (Text value : values) {\n                String str = value.toString();\n                String words[] = str.split(\",\");\n                int left = Integer.parseInt(words[1]);\n                int right = Integer.parseInt(words[2]);\n                float ans = 0;\n                if(right != 0)\n                    ans = (float)left/right;\n                \n                overall.add(Integer.parseInt(words[0]));\n                help.add(ans);\n                unixTime.add(Long.parseLong(words[3]));\n            }\n\n            //帮助度\n            float sum = 0, ans = 0.5f;//当一个产品没有任何帮助度相关信息时，设置帮助度为0.5\n            int cnt = 0;\n            for(float f : help){\n                if(f > 0.00001f){\n                    sum += f;\n                    cnt++;\n                }\n            }\n            if(cnt != 0)\n                ans = sum/cnt;\n            Collections.replaceAll(help, 0.0f, ans);\n            //时效性\n            long newTime = 1406073600;\n\n            //平均评级\n            float helpRate = 0;\n            double s1 = 0;\n            double s2 = 0;\n            int all = overall.size();\n            for(int i=0; i<all; i++){\n                float timeRate = (float)unixTime.get(i);\n                helpRate = help.get(i)*a + timeRate*timeRate/newTime*b;\n                s1 += (double)helpRate*overall.get(i);\n                s2 += (double)helpRate;\n            }\n\t\t    context.write(key, new Text(\"\" + s1/s2));\n        }\n\t}\n\t\n\t\n\tpublic static void main(String[] args) throws Exception{\n\t\tConfiguration configuration=new Configuration();\n\t\tString[] otherArgs=new GenericOptionsParser(configuration,args).getRemainingArgs();\n\t\tif(otherArgs.length!=2){\n\t\t\tSystem.err.println(\"Usage:reverseIndex <in> <out>\");\n\t\t\tSystem.exit(2);\n\t\t}\n\n        FileSystem fs=FileSystem.get(configuration);\n\t\tInputStream in = null;\n\t\tPath name = new Path(\"hdfs://localhost:9000/user/hadoop/isPaidPoster2/ans\");\n\t\tin = fs.open(name);\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(in));\n\n\t\t//rely\n        String line = \"\";\n        line = br.readLine();\n\t\twhile (line != null) {\n            rely.add(line);\n\t\t\tline = br.readLine();\n\t\t}\n\t\tbr.close();\n        in.close();\n\t\t\t\t\n\t\t//配置作业名\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tJob job=new Job(configuration, \"OverallWeights\");\n\t\tjob.setJarByClass(OverallWeights.class);\n\t\tjob.setMapperClass(TokenizerMapper.class);\n\t\tjob.setReducerClass(IntSumReducer.class);\n\t\tjob.setOutputKeyClass(Text.class);\n\t\tjob.setOutputValueClass(Text.class);\t\n        FileInputFormat.addInputPath(job, new Path(otherArgs[0]));\n\t\tFileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));\n\n\t\tSystem.exit(job.waitForCompletion(true)?0:1);\n\t}\n}\n\n```\n\nprint_zhe.py\n\n```python\n\"\"\"\n * @author 简\n * 绘制三种处理方式后的对比折线图.\n\"\"\"\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nf1 = open(\"./pic/overall\")\nf2 = open(\"./pic/overallClean\")\nf3 = open(\"./pic/overallWeights\")\nx1 = []\nx2 = []\nx3 = []\ny1 = []\ny2 = []\ny3 = []\n\nline = f1.readline()\nwhile line:\n    x = line.split()\n    x1.append(x[0])\n    #y1.append(int(x[1]))\n    y1.append(float(x[1]))\n    line = f1.readline()\nline = f2.readline()\nwhile line:\n    x = line.split()\n    x2.append(x[0])\n    y2.append(float(x[1]))\n    line = f2.readline()\nline = f3.readline()\nwhile line:\n    x = line.split()\n    x3.append(x[0])\n    y3.append(float(x[1]))\n    line = f3.readline()\n\nx=np.arange(100,350)\nplt.figure(figsize=(10, 10))\nl1=plt.plot(x1,y1,'r--',label='avgReviewOverall')\nl2=plt.plot(x2,y2,'b--',label='avgReviewOverallClean')\nl3=plt.plot(x3,y3,'g--',label='avgReviewOverallWeights')\nplt.plot(x1,y1,'ro-',x2,y2,'b+-',x3,y3,'g^-')\nplt.title('Average number of comments for each rated product')\nplt.xlabel('Rating')\nplt.ylabel('Average number of comments')\nplt.legend()\n#显示出所有设置\nplt.show()\n```\n\nAvgReview.java\n\n```java\n/**\n * @author 简\n * 计算各评级阶段的商品拥有的平均评论条数.\n */\npublic class AvgReview{\n\n    public static Map<String,Integer> rely1 = new HashMap<>();\n    public static Map<String,Integer> rely2 = new HashMap<>();\n    public static Set<String> rely3 = new HashSet<String>();\n\n    public static class MyMap extends Mapper<Object, Text, Text, IntWritable> {\n    \n        public void map(Object key, Text value, Context context) \n                throws IOException, InterruptedException {\n            \n            String review = value.toString();\n            Gson gson = new Gson();\n            KindleReview kindleReview = gson.fromJson(review, KindleReview.class);\n            String asin = kindleReview.getAsin();\n            String reviewId = kindleReview.getReviewerID();\n            if(!rely3.contains(reviewId)&&rely1.containsKey(asin)){\n                int overall = rely1.get(asin);\n                context.write(new Text(\"\" + overall), new IntWritable(1));\n            }\n        }\n    }\n\n  \n    public static class MyReduce extends\n            Reducer<Text,IntWritable, Text, Text> {\n\n        public void reduce(Text key, Iterable<IntWritable> values,\n                Context context) throws IOException, InterruptedException {\n            String overall = key.toString();\n\t        int i=0;\n            for (IntWritable val : values) {\n\t\t        i++;\n            }\n            context.write(key, new Text(\"\" + (float)i/rely2.get(overall)));\n            //context.write(key, new Text(\"\" + i));\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        //输入参数：KR评论json文件 商品评级 每种评级的商品种数 输出文件\n        Configuration conf = new Configuration();\n\n        FileSystem fs=FileSystem.get(conf);\n\t\tInputStream in1 = null;\n        InputStream in2 = null;\n\t\tInputStream in3 = null;\n\t\tPath name1 = new Path(\"hdfs://localhost:9000/user/hadoop/\"+args[1]+\"/part-r-00000\");\n\t\tPath name2 = new Path(\"hdfs://localhost:9000/user/hadoop/\"+args[2]+\"/part-r-00000\");\n\t\tPath name3 = new Path(\"hdfs://localhost:9000/user/hadoop/isPaidPoster2/ans\");\n\t\tin1 = fs.open(name1);\n\t\tin2 = fs.open(name2);\n\t\tin3 = fs.open(name3);\n\t\tBufferedReader br1 = new BufferedReader(new InputStreamReader(in1));\n\t\tBufferedReader br2 = new BufferedReader(new InputStreamReader(in2));\n        BufferedReader br3 = new BufferedReader(new InputStreamReader(in3));\n\n\t\t//rely\n        String line = \"\";\n        line = br1.readLine();\n\t\twhile (line != null) {\n            StringTokenizer itr = new StringTokenizer(line);\n            String str = itr.nextToken();\n\t\t\tint integer = (int)Double.parseDouble(itr.nextToken());\n            rely1.put(str, integer);\n\t\t\tline = br1.readLine();\n\t\t}\n        line = br2.readLine();\n\t\twhile (line != null) {\n            StringTokenizer itr = new StringTokenizer(line);\n            String str = itr.nextToken();\n\t\t\tint integer = Integer.parseInt(itr.nextToken());\n            rely2.put(str, integer);\n\t\t\tline = br2.readLine();\n\t\t}\n        line = br3.readLine();\n\t\twhile (line != null) {\n            rely3.add(line);\n\t\t\tline = br3.readLine();\n\t\t}\n\t\tbr1.close();\n        br2.close();\n        br3.close();\n        in1.close();\n        in2.close();\n        in3.close();\n\n        Job job = new Job(conf,\"AvgReview\"); \n        job.setJarByClass(AvgReview.class);\t\n        job.setMapperClass(MyMap.class);\n        job.setReducerClass(MyReduce.class);\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(Text.class);\n        job.setMapOutputKeyClass(Text.class);\n        job.setMapOutputValueClass(IntWritable.class);\n        FileInputFormat.addInputPath(job, new Path(args[0]));\n        FileOutputFormat.setOutputPath(job, new Path(args[3]));\n        System.exit(job.waitForCompletion(true) ? 0 : 1);\n    }\n}\n```\n\nAvgReview.java\n\n```java\n/**\n * @author 简\n * 计算各评级阶段的商品拥有的平均评论条数.\n */\npublic class AvgReview{\n\n    public static Map<String,Integer> rely1 = new HashMap<>();\n    public static Map<String,Integer> rely2 = new HashMap<>();\n    public static Set<String> rely3 = new HashSet<String>();\n\n    public static class MyMap extends Mapper<Object, Text, Text, IntWritable> {\n    \n        public void map(Object key, Text value, Context context) \n                throws IOException, InterruptedException {\n            \n            String review = value.toString();\n            Gson gson = new Gson();\n            KindleReview kindleReview = gson.fromJson(review, KindleReview.class);\n            String asin = kindleReview.getAsin();\n            String reviewId = kindleReview.getReviewerID();\n            if(!rely3.contains(reviewId)&&rely1.containsKey(asin)){\n                int overall = rely1.get(asin);\n                context.write(new Text(\"\" + overall), new IntWritable(1));\n            }\n        }\n    }\n\n  \n    public static class MyReduce extends\n            Reducer<Text,IntWritable, Text, Text> {\n\n        public void reduce(Text key, Iterable<IntWritable> values,\n                Context context) throws IOException, InterruptedException {\n            String overall = key.toString();\n\t        int i=0;\n            for (IntWritable val : values) {\n\t\t        i++;\n            }\n            context.write(key, new Text(\"\" + (float)i/rely2.get(overall)));\n            //context.write(key, new Text(\"\" + i));\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        //输入参数：KR评论json文件 商品评级 每种评级的商品种数 输出文件\n        Configuration conf = new Configuration();\n\n        FileSystem fs=FileSystem.get(conf);\n\t\tInputStream in1 = null;\n        InputStream in2 = null;\n\t\tInputStream in3 = null;\n\t\tPath name1 = new Path(\"hdfs://localhost:9000/user/hadoop/\"+args[1]+\"/part-r-00000\");\n\t\tPath name2 = new Path(\"hdfs://localhost:9000/user/hadoop/\"+args[2]+\"/part-r-00000\");\n\t\tPath name3 = new Path(\"hdfs://localhost:9000/user/hadoop/isPaidPoster2/ans\");\n\t\tin1 = fs.open(name1);\n\t\tin2 = fs.open(name2);\n\t\tin3 = fs.open(name3);\n\t\tBufferedReader br1 = new BufferedReader(new InputStreamReader(in1));\n\t\tBufferedReader br2 = new BufferedReader(new InputStreamReader(in2));\n        BufferedReader br3 = new BufferedReader(new InputStreamReader(in3));\n\n\t\t//rely\n        String line = \"\";\n        line = br1.readLine();\n\t\twhile (line != null) {\n            StringTokenizer itr = new StringTokenizer(line);\n            String str = itr.nextToken();\n\t\t\tint integer = (int)Double.parseDouble(itr.nextToken());\n            rely1.put(str, integer);\n\t\t\tline = br1.readLine();\n\t\t}\n        line = br2.readLine();\n\t\twhile (line != null) {\n            StringTokenizer itr = new StringTokenizer(line);\n            String str = itr.nextToken();\n\t\t\tint integer = Integer.parseInt(itr.nextToken());\n            rely2.put(str, integer);\n\t\t\tline = br2.readLine();\n\t\t}\n        line = br3.readLine();\n\t\twhile (line != null) {\n            rely3.add(line);\n\t\t\tline = br3.readLine();\n\t\t}\n\t\tbr1.close();\n        br2.close();\n        br3.close();\n        in1.close();\n        in2.close();\n        in3.close();\n\n        Job job = new Job(conf,\"AvgReview\"); \n        job.setJarByClass(AvgReview.class);\t\n        job.setMapperClass(MyMap.class);\n        job.setReducerClass(MyReduce.class);\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(Text.class);\n        job.setMapOutputKeyClass(Text.class);\n        job.setMapOutputValueClass(IntWritable.class);\n        FileInputFormat.addInputPath(job, new Path(args[0]));\n        FileOutputFormat.setOutputPath(job, new Path(args[3]));\n        System.exit(job.waitForCompletion(true) ? 0 : 1);\n    }\n}\n```\n\nSentimentAnalysis.java\n\n```java\n/**\n * @author 龚\n * 情绪分析.\n */\npublic class SentimentAnalysis {\n    public static void main(String[] args) throws Exception {\n        Configuration conf = new Configuration();\n        String[] otherArgs = (new GenericOptionsParser(conf, args)).getRemainingArgs();\n        if (otherArgs.length < 2) {\n            System.err.println(\"Usage: SentimentAnalysis <in> [<in>...] <out>\");\n            System.exit(2);\n        }\n        Job job = Job.getInstance(conf, \"SentimentAnalysis\");\n        job.setJarByClass(SentimentAnalysis.class);\n        job.setMapperClass(TokenizerMapper.class);\n        job.setCombinerClass(IReducer.class);\n        job.setReducerClass(IReducer.class);\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(IntWritable.class);\n        for (int i = 0; i < otherArgs.length - 1; ++i) {\n            FileInputFormat.addInputPath(job, new Path(otherArgs[i]));\n        }\n        FileOutputFormat.setOutputPath(job, new Path(otherArgs[otherArgs.length - 1]));\n        System.exit(job.waitForCompletion(true) ? 0 : 1);\n    }\n\n    public static class TokenizerMapper extends Mapper<Object, Text, Text, IntWritable> {\n        public void map(Object key, Text value, Context context) throws IOException, InterruptedException {\n            String line = value.toString();\n            Gson gson = new Gson();\n            KindleReview kindleReview = gson.fromJson(line, KindleReview.class);\n            String ReviewText = kindleReview.getReviewText();\n            Properties props = new Properties();\n            props.put(\"annotators\", \"tokenize, ssplit, pos, parse, sentiment\");\n            props.setProperty(\"parse.model\", \"edu/stanford/nlp/models/srparser/englishSR.ser.gz\");\n            StanfordCoreNLP pipeline = new StanfordCoreNLP(props);\n            int mainSentiment = 0;\n            if (ReviewText != null && ReviewText.length() > 0) {\n                int longest = 0;\n                Annotation annotation = pipeline.process(ReviewText);\n                for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n                    Tree tree = sentence.get(SentimentCoreAnnotations.SentimentAnnotatedTree.class);\n                    int sentiment = RNNCoreAnnotations.getPredictedClass(tree);\n                    String partText = sentence.toString();\n                    if (partText.length() > longest) {\n                        mainSentiment = sentiment;\n                        longest = partText.length();\n                    }\n                }\n            }\n            context.write(new Text(kindleReview.getAsin() + \" \" + kindleReview.getReviewerID()), new IntWritable(mainSentiment + 1));\n        }\n    }\n\n    public static class IReducer extends Reducer<Text, IntWritable, Text, IntWritable> {\n        public void reduce(Text key, Iterable<IntWritable> values,\n                           Context context\n        ) throws IOException, InterruptedException {\n            for (IntWritable value : values) {\n                context.write(key, value);\n            }\n        }\n    }\n\n}\n```\n\nOverallSentiment.java\n\n```java\n/**\n * @author 简\n * 计算经过剔除水军、修改权重、情绪分析后的商品评级.\n */\npublic class OverallSentiment {\n    \n    public static Set<String> rely = new HashSet<String>();\n\tpublic static Map<String,Integer> map = new HashMap<>();\n\t\n\tpublic static class TokenizerMapper extends Mapper<Object, Text, Text, Text> {\n\n\t\tpublic void map(Object key, Text value, Context context) throws IOException,InterruptedException{\n\t\t\t\n\t\t\tString line = value.toString();\n            Gson gson = new Gson();\n            KindleReview kindleReview = gson.fromJson(line, KindleReview.class);\n            String asin = kindleReview.getAsin();\n            float overall = kindleReview.getOverall();\n            String[] help = kindleReview.getHelpful();\n            Long unixReviewTime = kindleReview.getUnixReviewTime();\n\n            String reviewId = kindleReview.getReviewerID();\n            if(!rely.contains(reviewId)){//去除不良评判人员\n                overall = (float)(overall+map.get(asin + \" \" + reviewId))/2;\n                context.write(new Text(asin), new Text(overall + \",\" + help[0] + \",\" + help [1] + \",\" + unixReviewTime));\n            }\n\t\t}\n\t}\n\t\n\tpublic static class IntSumReducer extends Reducer<Text, Text, Text, Text>{\n        \n\t\tpublic void reduce(Text key,Iterable<Text> values,Context context)throws IOException,InterruptedException{\n            \n            int a = 1, b = 1;//帮助度和时效性的比例为1：1\n            ArrayList<Float> overall = new ArrayList<Float>();\n            ArrayList<Float> help = new ArrayList<Float>();\n            ArrayList<Long> unixTime = new ArrayList<Long>();\n            \n            for (Text value : values) {\n                String str = value.toString();\n                String words[] = str.split(\",\");\n                int left = Integer.parseInt(words[1]);\n                int right = Integer.parseInt(words[2]);\n                float ans = 0;\n                if(right != 0)\n                    ans = (float)left/right;\n                \n                overall.add(Float.parseFloat(words[0]));\n                help.add(ans);\n                unixTime.add(Long.parseLong(words[3]));\n            }\n\n            //帮助度\n            float sum = 0, ans = 0.5f;//当一个产品没有任何帮助度相关信息时，设置帮助度为0.5\n            int cnt = 0;\n            for(float f : help){\n                if(f > 0.00001f){\n                    sum += f;\n                    cnt++;\n                }\n            }\n            if(cnt != 0)\n                ans = sum/cnt;\n            Collections.replaceAll(help, 0.0f, ans);\n            //时效性\n            long newTime = 1406073600;\n\n            //平均评级\n            float helpRate = 0;\n            double s1 = 0;\n            double s2 = 0;\n            int all = overall.size();\n            for(int i=0; i<all; i++){\n                float timeRate = (float)unixTime.get(i);\n                helpRate = help.get(i)*a + timeRate*timeRate/newTime*b;\n                s1 += (double)helpRate*overall.get(i);\n                s2 += (double)helpRate;\n            }\n\t\t    context.write(key, new Text(\"\" + s1/s2));\n        }\n\t}\n\t\n\t\n\tpublic static void main(String[] args) throws Exception{\n\t\tConfiguration configuration=new Configuration();\n\t\tString[] otherArgs=new GenericOptionsParser(configuration,args).getRemainingArgs();\n\t\tif(otherArgs.length!=2){\n\t\t\tSystem.err.println(\"Usage:reverseIndex <in> <out>\");\n\t\t\tSystem.exit(2);\n\t\t}\n\n        FileSystem fs=FileSystem.get(configuration);\n\t\tInputStream in1 = null;\n        InputStream in2 = null;\n\t\tPath name1 = new Path(\"hdfs://localhost:9000/user/hadoop/isPaidPoster2/ans\");\n\t\tPath name2 = new Path(\"hdfs://localhost:9000/user/hadoop/sentiment/sentiment_analysis\");\n\t\tin1 = fs.open(name1);\n\t\tin2 = fs.open(name2);\n\t\tBufferedReader br1 = new BufferedReader(new InputStreamReader(in1));\t\t\n\t\tBufferedReader br2 = new BufferedReader(new InputStreamReader(in2));\n\n\t\t//rely\n        String line = \"\";\n        line = br1.readLine();\n\t\twhile (line != null) {\n            rely.add(line);\n\t\t\tline = br1.readLine();\n\t\t}\n        line = br2.readLine();\n\t\twhile (line != null) {\n            StringTokenizer itr = new StringTokenizer(line);\n            String asin = itr.nextToken();\n\t\t\tString reviewId = itr.nextToken();\n\t\t\tint integer = (int)Double.parseDouble(itr.nextToken());\n            map.put(asin + \" \" + reviewId, integer);\n\t\t\tline = br2.readLine();\n\t\t}\n\t\tbr1.close();\n        br2.close();\n        in1.close();\n        in2.close();\n\t\t\t\t\n\t\t//配置作业名\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tJob job=new Job(configuration, \"OverallSentiment\");\n\t\tjob.setJarByClass(OverallSentiment.class);\n\t\tjob.setMapperClass(TokenizerMapper.class);\n\t\tjob.setReducerClass(IntSumReducer.class);\n\t\tjob.setOutputKeyClass(Text.class);\n\t\tjob.setOutputValueClass(Text.class);\t\n        FileInputFormat.addInputPath(job, new Path(otherArgs[0]));\n\t\tFileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));\n\n\t\tSystem.exit(job.waitForCompletion(true)?0:1);\n\t}\n}\n```\n\nKindleReview.java\n\n```java\n/**\n * @author 龚\n * json格式数据处理类.\n */\nimport java.util.Arrays;\n\npublic class KindleReview {\n    String reviewerID;\n    String asin;\n    String reviewerName;\n    String[] helpful;\n    String reviewText;\n    int overall;\n    String summary;\n    long unixReviewTime;\n    String reviewTime;\n\n    public String getReviewerID() {\n        return reviewerID;\n    }\n\n    public void setReviewerID(String reviewerID) {\n        this.reviewerID = reviewerID;\n    }\n\n    public String getAsin() {\n        return asin;\n    }\n\n    public void setAsin(String asin) {\n        this.asin = asin;\n    }\n\n    public String getReviewerName() {\n        return reviewerName;\n    }\n\n    public void setReviewerName(String reviewerName) {\n        this.reviewerName = reviewerName;\n    }\n\n    public String[] getHelpful() {\n        return helpful;\n    }\n\n    public void setHelpful(String[] helpful) {\n        this.helpful = helpful;\n    }\n\n    public String getReviewText() {\n        return reviewText;\n    }\n\n    public void setReviewText(String reviewText) {\n        this.reviewText = reviewText;\n    }\n\n    public int getOverall() {\n        return overall;\n    }\n\n    public void setOverall(int overall) {\n        this.overall = overall;\n    }\n\n    public String getSummary() {\n        return summary;\n    }\n\n    public void setSummary(String summary) {\n        this.summary = summary;\n    }\n\n    public long getUnixReviewTime() {\n        return unixReviewTime;\n    }\n\n    public void setUnixReviewTime(long unixReviewTime) {\n        this.unixReviewTime = unixReviewTime;\n    }\n\n    public String getReviewTime() {\n        return reviewTime;\n    }\n\n    public void setReviewTime(String reviewTime) {\n        this.reviewTime = reviewTime;\n    }\n\n    @Override\n    public String toString() {\n        return \"KindleReview{\" +\n                \"reviewerID='\" + reviewerID + '\\'' +\n                \", asin='\" + asin + '\\'' +\n                \", reviewerName='\" + reviewerName + '\\'' +\n                \", helpful=\" + Arrays.toString(helpful) +\n                \", reviewText='\" + reviewText + '\\'' +\n                \", overall=\" + overall +\n                \", summary='\" + summary + '\\'' +\n                \", unixReviewTime=\" + unixReviewTime +\n                \", reviewTime='\" + reviewTime + '\\'' +\n                '}';\n    }\n}\n```\n\n ","tags":["project"]},{"title":"Markdown公式合集","url":"/Markdown公式合集/","content":"\n### 角标\n\n\"_\"—>down\n\"^\"—>up\n\n```\nx_1 \\\\\\\\\n\nx_1^2 \\\\\\\\\n\nx^2_1 \\\\\n\nx_{22}^{(n)} \\\\\n\n^*x^* \\\\\n\nx_{down}^{up}\n```\n\n\n$$\nx_1 \\\\\\\\\n\nx_1^2 \\\\\\\\\n\nx^2_1 \\\\\n\nx_{22}^{(n)} \\\\\n\n^*x^* \\\\\n\nx_{down}^{up}\n$$\n\n### 分号\n\nfrac\n\n```\n\\frac{x+y}{2} \\\\\n\n\\frac{1}{1+\\frac{1}{2}}\n```\n\n\n$$\n\\frac{x+y}{2} \\\\\n\n\\frac{1}{1+\\frac{1}{2}}\n$$\n\n### 根号\n\nsqrt\n第二和第三个的区别在于为了美观微调位置 ^_^\n\n```\n\\sqrt{2}<\\sqrt[3]{3} \\\\\n\n\\sqrt{1+\\sqrt[p]{1+a^2}} \\\\\n\n\\sqrt{1+\\sqrt[^p\\!]{1+a^2}}\n```\n\n\n$$\n\\sqrt{2}<\\sqrt[3]{3} \\\\\n\n\\sqrt{1+\\sqrt[p]{1+a^2}} \\\\\n\n\\sqrt{1+\\sqrt[^p\\!]{1+a^2}}\n$$\n\n### 求和、积分\n\nsum\nint\n\n```\n\\sum_{k=1}^{n}\\frac{1}{k} \\\\\n\n\\int_a^b f(x)dx \\\\\n\n\\int_a^b f(x)\\mathrm{d}x\n```\n\n$$\n\\sum_{k=1}^{n}\\frac{1}{k} \\\\\n\n\\int_a^b f(x)dx \\\\\n\n\\int_a^b f(x)\\mathrm{d}x\n$$\n\n### 空格\n\n```\n紧贴 a\\!b \\\\\n没有空格 ab \\\\\n小空格 a\\,b \\\\\n中等空格 a\\;b \\\\\n大空格 a\\ b \\\\\nquad空格 a\\quad b \\\\\n两个quad空格 a\\qquad b \\\\\n```\n\n\n$$\n紧贴 a\\!b \\\\\n没有空格 ab \\\\\n小空格 a\\,b \\\\\n中等空格 a\\;b \\\\\n大空格 a\\ b \\\\\nquad空格 a\\quad b \\\\\n两个quad空格 a\\qquad b \\\\\n$$\n\n### 括号\n\n```\n\\left(\\sum_{k=\\frac{1}{2}}^{N^2}\\frac{1}{k}\\right) \\\\\n(\\sum_{k=\\frac{1}{2}}^{N^2}\\frac{1}{k})\n```\n\n\n$$\n\\left(\\sum_{k=\\frac{1}{2}}^{N^2}\\frac{1}{k}\\right) \\\\\n(\\sum_{k=\\frac{1}{2}}^{N^2}\\frac{1}{k})\n$$\n\n### 矩阵\n\n```\n\\begin{matrix}1&2\\\\3&4\\end{matrix} \\\\\n\n\\begin{pmatrix}1 & 2\\\\\\\\3 &4\\end{pmatrix} \\\\\n\n\\begin{bmatrix}1 & 2\\\\\\\\3 &4\\end{bmatrix} \\\\\n\n\\begin{Bmatrix}1 & 2\\\\\\\\3 &4\\end{Bmatrix} \\\\\n\n\\begin{vmatrix}1 & 2\\\\\\\\3 &4\\end{vmatrix} \\\\\n\n\\left|\\begin{matrix}1 & 2\\\\\\\\3 &4\\end{matrix}\\right| \\\\\n\n\\begin{Vmatrix}1 & 2\\\\\\\\3 &4\\end{Vmatrix}\n```\n\n\n$$\n\\begin{matrix}1&2\\\\3&4\\end{matrix} \\\\\n\n\\begin{pmatrix}1 & 2\\\\\\\\3 &4\\end{pmatrix} \\\\\n\n\\begin{bmatrix}1 & 2\\\\\\\\3 &4\\end{bmatrix} \\\\\n\n\\begin{Bmatrix}1 & 2\\\\\\\\3 &4\\end{Bmatrix} \\\\\n\n\\begin{vmatrix}1 & 2\\\\\\\\3 &4\\end{vmatrix} \\\\\n\n\\left|\\begin{matrix}1 & 2\\\\\\\\3 &4\\end{matrix}\\right| \\\\\n\n\\begin{Vmatrix}1 & 2\\\\\\\\3 &4\\end{Vmatrix}\n$$\n\n```\n\\mathbf{X} =\n\\left( \\begin{array}{ccc}\nx_{11} & x\\_{12} & \\ldots \\\\\\\\\nx\\_{21} & x\\_{22} & \\ldots \\\\\\\\\n\\vdots & \\vdots & \\ddots\n\\end{array} \\right)\n```\n\n\n$$\n\\mathbf{X} =\n\\left( \\begin{array}{ccc}\nx_{11} & x\\_{12} & \\ldots \\\\\\\\\nx\\_{21} & x\\_{22} & \\ldots \\\\\\\\\n\\vdots & \\vdots & \\ddots\n\\end{array} \\right)\n$$\n\n### 长公式\n\n```\n不对齐\\\\\n\\begin{multline}\nx = a+b+c+{} \\\\\\\\\nd+e+f+g\n\\end{multline}\n\\\\对齐\\\\\n\\begin{aligned}\nx ={}& a+b+c+{} \\\\\\\\\n&d+e+f+g\n\\end{aligned}\n```\n\n\n$$\n不对齐\\\\\n\\begin{multline}\nx = a+b+c+{} \\\\\\\\\nd+e+f+g\n\\end{multline}\n\\\\对齐\\\\\n\\begin{aligned}\nx ={}& a+b+c+{} \\\\\\\\\n&d+e+f+g\n\\end{aligned}\n$$\n\n```\n\\left.\n\\begin{array}{l}\n\\text{if $n$ is even:}&n/2\\\\\n\\text{if $n$ is odd:}&3n+1\n\\end{array}\n\\right\\}\n=f(n)\n```\n\n$$\n\\left.\n\\begin{array}{l}\n\\text{if $n$ is even:}&n/2\\\\\n\\text{if $n$ is odd:}&3n+1\n\\end{array}\n\\right\\}\n=f(n)\n$$\n\n### 公式组\n\n居中\n\n```\n\\begin{gather}\na = b+c+d \\\\\nx = y+z\n\\end{gather}\n```\n\n\n$$\n\\begin{gather}\na = b+c+d \\\\\nx = y+z\n\\end{gather}\n$$\n对齐\n\n```\n\\begin{align}\na &= b+c+d \\tag{行标}\\\\\nx &= y+z\n\\end{align}\n```\n\n\n$$\n\\begin{align}\na &= b+c+d \\tag{行标}\\\\\nx &= y+z\n\\end{align}\n$$\n\n### 分段函数\n\n```\ny=\\begin{cases}\n-x,\\quad x\\leq 0 \\\\\\\\\nx,\\quad x>0\n\\end{cases}\n```\n\n\n$$\ny=\\begin{cases}\n-x,\\quad x\\leq 0 \\\\\\\\\nx,\\quad x>0\n\\end{cases}\n$$\n\n### 划线、制表\n\n```\n\\left(\\begin{array}{|c|c|}\n1 & 2 \\\\\n\\hline\n3 & 4\n\\end{array}\\right) \\\\\n\n\\begin{array}{|c|c|}\n\\hline11 & \\cdots \\\\\n\\hline3 & 4 \\\\\n\\hline\n\\end{array}\n```\n\n\n$$\n\\left(\\begin{array}{|c|c|}\n1 & 2 \\\\\n\\hline\n3 & 4\n\\end{array}\\right) \\\\\n\n\\begin{array}{|c|c|}\n\\hline\n11 & \\cdots \\\\\n\\hline\n3 & 4 \\\\\n\\hline\n\\end{array}\n$$\n\n### 占位符\n\n| 符号        | 编码          | 符号                | 编码                   |\n| ----------- | ------------- | ------------------- | ---------------------- |\n| &forall;    | `&forall;`    | &exist;             | `&exist;`              |\n| &amp;       | `&amp;`       | &yen;               | `&yen;`                |\n| &iquest;    | `&iquest;`    | &euro;              | `&euro;`               |\n| &sect;      | `&sect;`      | &cent;              | `&cent;`               |\n| &times;     | `&times;`     | &pound;             | `&pound;`              |\n| &divide;    | `&divide;`    | &deg;               | `&deg;`                |\n| &plusmn;    | `&plusmn;`    | &permil;            | `&permil;`             |\n| &infin;     | `&infin;`     | &there4;            | `&there4; &therefore;` |\n| &ne;        | `&ne;`        | &because;           | `&because;`            |\n| &equiv;     | `&equiv;`     | &larr;              | `&larr;`               |\n| &le;        | `&le;`        | &rarr;              | `&rarr;`               |\n| &ge;        | `&ge;`        | &lArr;              | `&lArr;`               |\n| &approx;    | `&approx;`    | &rArr;              | `&rArr;`               |\n| &perp;      | `&perp;`      | &hArr;              | `&hArr;`               |\n| &oplus;     | `&oplus;`     | &emptyset;          | `&emptyset;`           |\n| &bigotimes; | `&bigotimes;` | &in;                | `&in;`                 |\n| &bigodot;   | `&bigodot;`   | &notin;             | `&notin;`              |\n| &mid;       | `&mid;`       | &subset; &subseteq; | `&subset; &subseteq;`  |\n| &pi;        | `&pi;`        | &supset; &supseteq; | `&supset; &supseteq;`  |\n| &sim;       | `&sim;`       | &tilde;             | `&tilde;`              |\n\n### 希腊字母\n\n```\n\\begin{array}{|c|c|c|c|}\n\\hline\n{\\alpha} & {\\backslash alpha} & {\\theta} & {\\backslash theta} \\\\\\\\\n\\hline\n{\\beta} & {\\backslash beta} & {\\vartheta} & {\\backslash vartheta} \\\\\\\\\n\\hline\n{\\gamma} & {\\backslash gamma} & {\\iota} & {\\backslash iota} \\\\\\\\\n\\hline\n\\end{array}\n```\n\n\n$$\n\\begin{array}{|c|c|c|c|c|c|c|c|}\n\\hline\n{\\alpha} & {\\backslash alpha} & {\\theta} & {\\backslash theta} & {o} & {o} & {\\upsilon} & {\\backslash upsilon} \\\\\\\\\n\\hline\n{\\beta} & {\\backslash beta} & {\\vartheta} & {\\backslash vartheta} & {\\pi} & {\\backslash pi} & {\\phi} & {\\backslash phi} \\\\\\\\\n\\hline\n{\\gamma} & {\\backslash gamma} & {\\iota} & {\\backslash iota} & {\\varpi} & {\\backslash varpi} & {\\varphi} & {\\backslash varphi} \\\\\\\\\n\\hline\n{\\delta} & {\\backslash delta} & {\\kappa} & {\\backslash kappa} & {\\rho} & {\\backslash rho} & {\\chi} & {\\backslash chi} \\\\\\\\\n\\hline\n{\\epsilon} & {\\backslash epsilon} & {\\lambda} & {\\backslash lambda} & {\\varrho} & {\\backslash varrho} & {\\psi} & {\\backslash psi} \\\\\\\\\n\\hline\n{\\varepsilon} & {\\backslash varepsilon} & {\\mu} & {\\backslash mu} & {\\sigma} & {\\backslash sigma} & {\\omega} & {\\backslash omega} \\\\\\\\\n\\hline\n{\\zeta} & {\\backslash zeta} & {\\nu} & {\\backslash nu} & {\\varsigma} & {\\backslash varsigma} & {\\nabla} & {\\backslash nabla} \\\\\\\\\n\\hline\n{\\eta} & {\\backslash eta} & {\\xi} & {\\backslash xi} & {\\tau} & {\\backslash tau} & {\\partial} & {\\backslash partial} \\\\\\\\\n\\hline\n{\\Gamma} & {\\backslash Gamma} & {\\Lambda} & {\\backslash Lambda} & {\\Sigma} & {\\backslash Sigma} & {\\Psi} & {\\backslash Psi} \\\\\\\\\n\\hline\n{\\Delta} & {\\backslash Delta} & {\\Xi} & {\\backslash Xi} & {\\Upsilon} & {\\backslash Upsilon} & {\\Omega} & {\\backslash Omega} \\\\\\\\\n\\hline\n{\\Omega} & {\\backslash Omega} & {\\Pi} & {\\backslash Pi} & {\\Phi} & {\\backslash Phi} & {} & {} \\\\\\\\\n\\hline\n\\end{array}\n$$\n\n### 下方括号\n\n```\nf(x_1,x_2,\\underbrace{\\ldots}_{\\rm ldots} ,x_n) = x_1^2 + x_2^2 + \\underbrace{\\cdots}_{\\rm cdots} + x_n^2  \\\\\n\\underbrace{abcdefg}_{n} \\\\\n\\overbrace{abcdefg}^{n} \\\\\n\\fbox{abcdefg}\n```\n\n$$\nf(x_1,x_2,\\underbrace{\\ldots}_{\\rm ldots} ,x_n) = x_1^2 + x_2^2 + \\underbrace{\\cdots}_{\\rm cdots} + x_n^2  \\\\\n\\underbrace{abcdefg}_{n} \\\\\n\\overbrace{abcdefg}^{n} \\\\\n\\fbox{abcdefg}\n$$\n\n### 矢量\n\n```\n\\vec{a} \\cdot \\vec{b}=0\n```\n\n$$\n\\vec{a} \\cdot \\vec{b}=0\n$$\n\n### 箭头\n\n```\n\\overleftarrow{xy}  \\overleftrightarrow{xy}  \\overrightarrow{xy}  \\overline{xy}\n```\n\n$$\n\\overleftarrow{xy} \\quad \\overleftrightarrow{xy} \\quad \\overrightarrow{xy} \\quad \\overline{xy}\n$$\n\n### 极限\n\n```\n\\lim_{n \\to +\\infty} \\frac{1}{n(n+1)}    \\lim_{x\\leftarrow{示例}} \\frac{1}{n(n+1)}\n```\n\n$$\n\\lim_{n \\to +\\infty} \\frac{1}{n(n+1)}  \\quad \\lim_{x\\leftarrow{示例}} \\frac{1}{n(n+1)}\n$$\n\n### 累乘、集合\n\n```\n\\prod_{i=1}^n \\frac{1}{i^2}      \\bigcup_{i=1}^{2} R\n```\n\n$$\n\\prod_{i=1}^n \\frac{1}{i^2}  \\quad \\bigcup_{i=1}^{2} R\n$$\n\n### 戴帽符\n\n```\n\\hat{x}  \\widehat{xyz}  \\tilde{x}   \\widetilde{xyz}\n```\n\n$$\n\\hat{x} \\quad \\widehat{xyz} \\quad \\tilde{x} \\quad \\widetilde{xyz}\n$$\n\n### 其他字体\n\n```\n{\\frak {sample}}   {\\tt {sample}}   {\\sf {sample}}\n```\n\n$$\n{\\frak {sample}} \\quad {\\tt {sample}} \\quad {\\sf {sample}}\n$$\n\n### 其他颜色\n\n```\n\\color{maroon}{sample}  \\color{lime}{sample} \\color{blue}{sample}\n```\n\n$$\n\\color{maroon}{sample} \\quad \\color{lime}{sample} \\quad \\color{blue}{sample}\n$$\n\n### 删除线\n\n```\n\\require{cancel}\n\\cancel{x+y}\\\\\n\\bcancel{x+y}\\\\\n\\xcancel{x+y}\\\\\n\\cancelto{a+b}{x+y}\n```\n\n$$\n\\require{cancel}\n\\cancel{x+y}\\\\\n\\bcancel{x+y}\\\\\n\\xcancel{x+y}\\\\\n\\cancelto{a+b}{x+y}\n$$\n\n### 整段删除\n\n```\n\\require{enclose}\n\\enclose{horizontalstrike}{x+y}\\\\\n\\enclose{verticalstrike}{\\frac{x}{y}}\\\\\n\\enclose{updiagonalstrike}{x+y}\\\\\n\\enclose{downdiagonalstrike}{x+y}\\\\\n\\enclose{horizontalstrike,updiagonalstrike}{x+y}\n```\n\n$$\n\\require{enclose}\n\\enclose{horizontalstrike}{x+y}\\\\\n\\enclose{verticalstrike}{\\frac{x}{y}}\\\\\n\\enclose{updiagonalstrike}{x+y}\\\\\n\\enclose{downdiagonalstrike}{x+y}\\\\\n\\enclose{horizontalstrike,updiagonalstrike}{x+y}\n$$\n\n### 交换图表\n\n```\n\\require{AMScd}\n\\begin{CD}\n    A @>>> B @>{\\text{very long label}}>> C \\\\\n    @. @AAA @| \\\\\n    D @= E @<<< F\n\\end{CD}\n```\n\n$$\n\\require{AMScd}\n\\begin{CD}\n    A @>>> B @>{\\text{very long label}}>> C \\\\\n    @. @AAA @| \\\\\n    D @= E @<<< F\n\\end{CD}\n$$\n\n","tags":["collection"]},{"title":"Hexo","url":"/Hexo/","content":"\n## 如何使用\n\n### 基本命令\n\n```\nhexo new [layout]<title>` # 如果标题包含空格的话，请使用引号括起来\nhexo new \"post title with whitespace\"\n\nhexo generate # 生成静态文件\n\nhexo -d # deploy文件生成后立即部署网站\nhexo -w # watch监视文件变动\n\nhexo server # 启动服务器，在本地查看\n\nhexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public）\n\n```\n\n### 其他操作\n\n1. 如何使用双标签\n\n   tags: [标签1, 标签2]\n\n2. 如何是使用数学公式渲染器\n\n   mathjax: true\n\n3. 评论开关\n   comment: true\n\n### 写作提示\n\n> 这是一段引用这是一段引用这是一段引用这是一段引用这是一段引用这是一段引用这是一段引用这是一段引用这是一段引用这是一段引用\n>\n> 绿色康\n\n1. 安利你偶尔\n\n2. 斯丁哦[^1]\n\n3. 电视`里能`[^2]\n\n4. 僧\n\n5. 孙工二**十个**\n\n   `if else when{}`<or>橘色显示</or>\n\n   ```java\n   public static void main(){\n   \n   }\n   ```\n\n\n- [链接](http://www.jiziti.fun)\n- <u>下划线</u>\n- *斜体*\n- 无序列表\n- ~~删除线~~\n\n[^1]: 第一次使用脚注\n[^2]: 其他\n\n## 更新变动\n\n- [x] 样式微调\n- [x] 评论功能\n- [x] 数学公式渲染功能\n- [x] 回到顶部功能\n- [x] 图片懒加载功能\n- [x] [预计更换评论功能，增加匿名评论](https://www.axutongxue.com/2019/05/blogger-valine.html)\n- [ ] 预计改变渲染引擎，使渲染加速katex\n- [ ] CDN加速\n\n","tags":["collection"]}]